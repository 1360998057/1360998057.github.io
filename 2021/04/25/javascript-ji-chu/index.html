<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Javascript基础, 摘录记">
    <meta name="description" content="javascript,node,html,css">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Javascript基础 | 摘录记</title>
    <link rel="icon" type="image/png" href="/medias/logo2.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">摘录记</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>主页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">摘录记</div>
        <div class="logo-desc">
            
            javascript,node,html,css
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			主页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/1360998057/1360998057.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0c3c4e;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {

        0%,
        to {
            transform: rotate(0);
        }

        20%,
        60% {
            transform: rotate(-25deg);
        }

        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/1360998057/1360998057.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
    data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
            d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
            fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path
            d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
            fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Javascript基础</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Javascript/">
                                <span class="chip bg-color">Javascript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-04-25
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    18.4k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>Javascript 是一门脚本语言 在node.js还没有出世时是用于运行于手机端和网页端口一门脚本语言。</p>
<h4 id="JavaScript组成"><a href="#JavaScript组成" class="headerlink" title="JavaScript组成"></a>JavaScript组成</h4><ul>
<li><p><strong>ECMAScript</strong>：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。</p>
</li>
<li><p><strong>DOM</strong>：文档对象模型，操作<strong>网页上的元素</strong>的API。比如让盒子移动、变色、轮播图等。</p>
</li>
<li><p><strong>BOM</strong>：浏览器对象模型，操作<strong>浏览器部分功能</strong>的API。比如让浏览器自动滚动。</p>
<p><strong>ECMAScript</strong> 简单来说就是一种编写的规范和语法结构。 JavaScript 现在最常用语法简称为ES6语法。</p>
<p><strong>DOM</strong> 指的是 html元素节点。 Vue React 这类的框架 本质是使用MVVM 使 dom元素进行动态的刷新和变化。</p>
<p><strong>BOM</strong> 指的是浏览器 可以使用JavaScript 操控和限制浏览器的功能。</p>
</li>
</ul>
<h4 id="javascript-写法"><a href="#javascript-写法" class="headerlink" title="javascript 写法"></a>javascript 写法</h4><p>Javascript 内嵌式</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs JavaScript">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;<br><span class="hljs-keyword">let</span> a= <span class="hljs-number">123</span>;<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>



<p>Javascript 外链式</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">"tool.js"</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>



<h4 id="Javascript基础语法"><a href="#Javascript基础语法" class="headerlink" title="Javascript基础语法"></a>Javascript基础语法</h4><p>alert 警告</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-string">"警告"</span>);<br></code></pre></td></tr></tbody></table></figure>

<p>控制台输出</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript">consoloe.log();<br></code></pre></td></tr></tbody></table></figure>



<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在使用JavaScript （ES6之前）一直用var 声明变量</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var name='小红' // 字符串<br>var age =13 // 数字<br></code></pre></td></tr></tbody></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>在使用JavaScript和其他语言的时候 只能由英语字母、数字、下划线、美元符号$构成，且不能以数字开头，并且不能是JavaScript保留字。</p>
<p>一般使用”<strong>大驼峰写法</strong>“ 和”<strong>小驼峰写法</strong>“.</p>
<p>1.建议用驼峰命名规则：getElementById/matherAndFather/aaaOrBbbAndCcc</p>
<p>2.变量命名必须以字母或是下标符号”_”或者”$”为开头。</p>
<p>3.变量名长度不能超过255个字符。</p>
<p>4.变量名中不允许使用空格，首个字不能为数字。</p>
<p>5.不用使用脚本语言中保留的<strong>关键字</strong>及<strong>保留字</strong>作为变量名。</p>
<p>6.变量名区分大小写(javascript是区分大小写的语言)。</p>
<p>7.汉语可以作为变量名。但是不建议使用，因为 low。</p>
<h4 id="变量声明的提升"><a href="#变量声明的提升" class="headerlink" title="变量声明的提升"></a>变量声明的提升</h4><p>当javascript在加载的时候 会进行预编译 会将变量声明提升到最前面,但是不会将赋值提升。 当没有赋值属性 会出现 undefind。</p>
<h5 id="在JS中一共有六种数据类型"><a href="#在JS中一共有六种数据类型" class="headerlink" title="在JS中一共有六种数据类型"></a><strong>在JS中一共有六种数据类型</strong></h5><ul>
<li><strong>基本数据类型（值类型）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。</li>
<li><strong>引用数据类型（引用类型）</strong>：Object 对象。</li>
</ul>
<p>注意：内置对象<strong>function</strong>(函数)、Array(数组)、Date（时间对象）、RegExp(正则表达式)、Error(错误抛出)等都是属于Object类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。</p>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><p> typeof 可以返回数据的类型</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs JavaScript">&lt;script&gt;<br>      <span class="hljs-keyword">var</span> array = [];<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> array) <span class="hljs-comment">//返回object;</span><br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>



<h4 id="数值型：Number"><a href="#数值型：Number" class="headerlink" title="数值型：Number"></a>数值型：Number</h4><p>最大值：<code>Number.MAX_VALUE</code>，这个值为： 1.7976931348623157e+308</p>
<p>最小值：<code>Number.MIN_VALUE</code>，这个值为： 5e-324</p>
<p>number ：整数 浮点数 </p>
<h4 id="NaN和isNaN-函数"><a href="#NaN和isNaN-函数" class="headerlink" title="NaN和isNaN()函数"></a>NaN和isNaN()函数</h4><p>NaN：是一个特殊的数字，表示Not a Number，非数值。比如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log("abc" / 18);  //结果是NaN<br><br>console.log("abc" * "abcd"); //按理说，字符串相乘是没有结果的，但如果你非要让JS去算，它就一定会给你一个结果。结果是NaN<br></code></pre></td></tr></tbody></table></figure>

<p>注意：<code>typeof NaN</code>的返回结果是number。</p>
<p>Undefined和任何数值计算的结果为NaN。NaN 与任何值都不相等，包括 NaN 本身。</p>
<p>（2）isNaN() :任何不能被转换为数值的值，都会让这个函数返回 true。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">isNaN(NaN);// true<br>isNaN("blue"); // true<br>isNaN(123); // false<br><br></code></pre></td></tr></tbody></table></figure>



<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>当JavaScript 字符串为数字的 和数字相加 相加后有结果会返回 number值。 <code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 都会进行隐式转换。</p>
<h4 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型: boolean"></a>布尔型: boolean</h4><p> 分为 ture ,false   ture 输出为 1 false 为 0。</p>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p>null 为空, undefind 为未定义。</p>
<h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 : String"></a>字符串 : String</h4><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"abcde"</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">"生命壹号"</span>;<br><span class="hljs-keyword">var</span> c = <span class="hljs-string">"123123"</span>;<br><span class="hljs-keyword">var</span> d = <span class="hljs-string">"哈哈哈哈哈"</span>;<br><span class="hljs-keyword">var</span> e = <span class="hljs-string">""</span>;     <span class="hljs-comment">//空字符串</span><br></code></pre></td></tr></tbody></table></figure>



<h4 id="其他的简单类型-–-gt-String"><a href="#其他的简单类型-–-gt-String" class="headerlink" title="其他的简单类型 –> String"></a>其他的简单类型 –&gt; String</h4><p><strong>方法一：变量+”” 或者 变量+”abc”</strong></p>
<p>举例如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var a = 123;  // Number 类型<br>console.log(a + '');  // 转换成 String 类型<br>console.log(a + 'haha');  // 转换成 String 类型<br></code></pre></td></tr></tbody></table></figure>

<p>上面的例子中，打印的结果，都是字符串类型的数据。</p>
<p><strong>方法二：调用toString()方法</strong></p>
<p>举例如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">变量.toString()<br></code></pre></td></tr></tbody></table></figure>

<p>【重要】该方法<strong>不会影响到原变量</strong>，它会将转换的结果返回。当然我们还可以直接写成<code>a = a.toString()</code>，这样的话，就是直接修改原变量。</p>
<p>注意：null和undefined这两个值没有toString()方法，所以它们不能用方法二。如果调用，会报错。</p>
<p><strong>方法三：使用String()函数</strong></p>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">String(变量)<br></code></pre></td></tr></tbody></table></figure>

<p>使用String()函数做强制类型转换时：</p>
<ul>
<li>对于Number和Boolean而言，实际上就是调用toString()方法。</li>
<li>但是对于null和undefined，就不会调用toString()方法。它会将 null 直接转换为 “null”。将 undefined 直接转换为 “undefined”。</li>
</ul>
<h4 id="其他的数据类型-–-gt-Number"><a href="#其他的数据类型-–-gt-Number" class="headerlink" title="其他的数据类型 –> Number"></a>其他的数据类型 –&gt; Number</h4><p>方式一：使用Number()函数</p>
<p><strong>情况一：字符串 –&gt; 数字</strong></p>
<ul>
<li>1.如果字符串中是纯数字，则直接将其转换为数字。</li>
<li>2.如果字符串中有非数字的内容，则转换为NaN。（此处可以看到Number()函数的局限性）</li>
<li>3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0。</li>
</ul>
<p><strong>情况二：布尔 –&gt; 数字</strong></p>
<ul>
<li>true 转成 1</li>
<li>false 转成 0</li>
</ul>
<p><strong>情况三：null –&gt; 数字</strong></p>
<ul>
<li>结果为：0</li>
</ul>
<p><strong>情况四：undefined –&gt; 数字</strong></p>
<ul>
<li>结果为：NaN</li>
</ul>
<p><strong>方式二：<code>parseInt()</code>：字符串 -&gt; 整数【重要】</strong></p>
<p>parseInt()是专门用来对付字符串的。向下取整数。</p>
<p><strong>parseInt()的作用是将字符串中的有效的整数内容转为数字</strong>。parse表示“转换”，Int表示“整数”（注意<code>Int</code>的拼写）。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">parseInt("5");<br></code></pre></td></tr></tbody></table></figure>

<p>得到的结果是数字5。</p>
<p><strong>parseInt()还具有以下特性</strong>：</p>
<p>（1）<strong>只保留字符串最开头的数字</strong>，后面的中文自动消失。例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log(parseInt("2017在公众号上写了6篇文章"));  //打印结果：2017<br><br>console.log(parseInt("2017.01在公众号上写了6篇文章"));  //打印结果仍是：2017   （说明只会取整数）<br><br>console.log(parseInt("aaa2017.01在公众号上写了6篇文章"));  //打印结果：NaN<br></code></pre></td></tr></tbody></table></figure>

<p>（2）自动带有截断小数的功能：<strong>向下取整，不四舍五入</strong>(取整函数)。</p>
<p><strong>parseFloat()：字符串 –&gt; 浮点数（小数）其他和 parseInt 一样</strong></p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><p>运算符的优先级如下：（越往上，优先级越高）</p>
<ul>
<li><p><code>.</code>、<code>[]</code>、<code>new</code></p>
</li>
<li><p>()</p>
</li>
<li><p>++、–</p>
</li>
<li><p><code>!</code>、<code>~</code>、<code>+</code>（单目）、<code>-</code>（单目）、<code>typeof</code>、<code>void</code>、<code>delete</code></p>
</li>
<li><p><code>%</code>、<code>*</code>、<code>/</code></p>
</li>
<li><p><code>+</code>（双目）、<code>-</code>（双目）</p>
</li>
<li><p><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code></p>
</li>
<li><p><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></p>
</li>
<li><p><code>==</code>、<code>!==</code>、<code>===</code></p>
</li>
<li><p><code>&amp;</code></p>
</li>
<li><p><code>^</code></p>
</li>
<li><p><code>|</code></p>
</li>
<li><p><code>&amp;&amp;</code></p>
</li>
<li><p><code>||</code></p>
</li>
<li><p><code>?:</code></p>
</li>
<li><p><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code></p>
</li>
<li><p><code>,</code></p>
</li>
</ul>
<p>备注：你在实际写代码的时候，如果不清楚哪个优先级更高，可以把括号运用上。</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>三元运算符也叫条件运算符。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">条件表达式?语句1:语句2;<br></code></pre></td></tr></tbody></table></figure>



<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>数学运算符</p>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>用<code>{}</code>包围起来的代码，就是代码块。</p>
<p>JS中的代码块，只具有<strong>分组</strong>的作用，没有其他的用途。</p>
<p>代码块中的内容，在外部是完全可见的。举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">{<br>    var a = 2;<br>    alert("smyhvae");<br>    console.log("永不止步");<br>}<br><br>console.log("a = " + a);<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：（可以看出，虽然变量 a 是定义在代码块中的，但是在外部依然可以访问）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">永不止步<br>a = 2<br></code></pre></td></tr></tbody></table></figure>



<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。</p>
<h4 id="流程控制语句分类"><a href="#流程控制语句分类" class="headerlink" title="流程控制语句分类"></a>流程控制语句分类</h4><ul>
<li>顺序结构</li>
<li>选择结构：if语句、switch语句</li>
<li>循环结构：while语句、for语句</li>
</ul>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句有以下三种。</p>
<h3 id="1、条件判断语句"><a href="#1、条件判断语句" class="headerlink" title="1、条件判断语句"></a>1、条件判断语句</h3><blockquote>
<p>条件成立才执行。如果条件不成立，那就什么都不做。</p>
</blockquote>
<p>格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">if (条件表达式) {<br>    // 条件为真时，做的事情<br><br>}<br></code></pre></td></tr></tbody></table></figure>



<h3 id="2、条件分支语句"><a href="#2、条件分支语句" class="headerlink" title="2、条件分支语句"></a>2、条件分支语句</h3><p>格式1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">if (条件表达式) {<br>    // 条件为真时，做的事情<br><br>} else {<br>    // 条件为假时，做的事情<br><br>}<br></code></pre></td></tr></tbody></table></figure>

<p>格式：（多分支的if语句）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">if (条件表达式1) {<br>    // 条件1为真时，做的事情<br><br>} else if (条件表达式2) {<br>    // 条件1不满足，条件2满足时，做的事情<br><br>} else if (条件表达式3) {<br>    // 条件1、2不满足，条件3满足时，做的事情<br><br>} else {<br>    // 条件1、2、3都不满足时，做的事情<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>以上所有的语句体中，只执行其中一个。</p>
<h4 id="switch语句（条件分支语句）"><a href="#switch语句（条件分支语句）" class="headerlink" title="switch语句（条件分支语句）"></a>switch语句（条件分支语句）</h4><p>switch语句也叫条件分支语句。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">switch(表达式) {<br>    case 值1：<br>        语句体1;<br>        break;<br>    case 值2：<br>        语句体2;<br>        break;<br>    default：<br>        语句体 n+1;<br>        break;<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p><strong>for循环的语法</strong></p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">for(①初始化表达式; ②条件表达式; ④更新表达式){<br>    ③语句...<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>执行流程：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">①执行初始化表达式，初始化变量（初始化表达式只会执行一次）<br><br>②执行条件表达式，判断是否执行循环：<br>    如果为true，则执行循环③<br>    如果为false，终止循环<br><br>④执行更新表达式，更新表达式执行完毕继续重复②<br></code></pre></td></tr></tbody></table></figure>

<p>for循环举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">for (var i = 1; i &lt;= 100; i++) {<br>    console.log(i);<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">while(条件表达式){<br>    语句...<br>}<br></code></pre></td></tr></tbody></table></figure>



<h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">do{<br>    语句...<br>}while(条件表达式)<br><br></code></pre></td></tr></tbody></table></figure>

<p>执行流程：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">do...while语句在执行时，会先执行循环体：<br><br>    循环体执行完毕以后，在对while后的条件表达式进行判断：<br>        如果结果为true，则继续执行循环体，执行完毕继续判断以此类推<br>        如果结果为false，则终止循环<br><br><br></code></pre></td></tr></tbody></table></figure>



<h5 id="while循环和-do…while循环的区别"><a href="#while循环和-do…while循环的区别" class="headerlink" title="while循环和 do…while循环的区别"></a>while循环和 do…while循环的区别</h5><p>这两个语句的功能类似，不同的是：</p>
<ul>
<li>while是先判断后执行，而do…while是先执行后判断。</li>
</ul>
<p>也就是说，do…while可以保证循环体至少执行一次，而while不能。</p>
<h5 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h5><p>break退出循环 continue跳出本次循环</p>
<h5 id="函数的介绍"><a href="#函数的介绍" class="headerlink" title="函数的介绍"></a>函数的介绍</h5><p>函数：就是将一些功能或语句进行<strong>封装</strong>，在需要的时候，通过<strong>调用</strong>的形式，执行这些语句。</p>
<ul>
<li><strong>函数也是一个对象</strong></li>
<li>使用<code>typeof</code>检查一个函数对象时，会返回function</li>
</ul>
<p><strong>函数的作用</strong>：</p>
<ul>
<li>将大量重复的语句写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动。</li>
<li>简化编程，让编程模块化。</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log("你好");<br>sayHello(); // 调用函数<br><br>// 定义函数<br>function sayHello(){<br>    console.log("欢迎");<br>    console.log("welcome");<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h4><p><strong>第一步：函数的定义</strong></p>
<p><strong>方式一</strong>：使用<code>函数声明</code>来创建一个函数。语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">function 函数名([形参1,形参2...形参N]){  // 备注：语法中的中括号，表示“可选”<br>    语句...<br>}<br></code></pre></td></tr></tbody></table></figure>



<p>解释如下：</p>
<ul>
<li>function：是一个关键字。中文是“函数”、“功能”。</li>
<li>函数名字：命名规定和变量的命名规定一样。只能是字母、数字、下划线、美元符号，不能以数字开头。</li>
<li>参数：可选。</li>
<li>大括号里面，是这个函数的语句。</li>
</ul>
<p><strong>方式二</strong>：使用<code>函数表达式</code>来创建一个函数。语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var 函数名  = function([形参1,形参2...形参N]){<br>    语句....<br>}<br></code></pre></td></tr></tbody></table></figure>



<h5 id="第二步：函数的调用"><a href="#第二步：函数的调用" class="headerlink" title="第二步：函数的调用"></a>第二步：函数的调用</h5><p>函数调用的语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">函数名字();<br></code></pre></td></tr></tbody></table></figure>

<h5 id="函数的参数：形参和实参"><a href="#函数的参数：形参和实参" class="headerlink" title="函数的参数：形参和实参"></a>函数的参数：形参和实参</h5><p><img src="http://img.smyhvae.com/20180118_1130.png" alt="img"></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">sum(3,4);<br>sum("3",4);<br>sum("Hello","World");<br><br>//函数：求和<br>function sum(a, b) {<br>    console.log(a + b);<br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>可以通过arguments获取所有的实际传递的参数</p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">function add(){<br>                //arguments:可以获取所有实际传递的参数<br>                var sum = 0;<br>                console.log(arguments)<br>                for(var i = 0;i&lt;arguments.length;i++){<br>                    sum = sum + arguments[i]<br>                }<br>                return sum<br>            }<br>            <br>add(1,3,3,5,6,7)<br></code></pre></td></tr></tbody></table></figure>

<h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h4><p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log(sum(3, 4));<br><br>//函数：求和<br>function sum(a, b) {<br>    return a + b;<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>return的作用是结束方法。</p>
<p>注意：</p>
<ul>
<li>return后的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。</li>
<li>在函数中return后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出）</li>
<li>如果return语句后不跟任何值，就相当于返回一个undefined</li>
<li>如果函数中不写return，则也会返回undefined</li>
<li>返回值可以是任意的数据类型，可以是对象，也可以是函数。</li>
</ul>
<h5 id="函数名、函数体和函数加载问题（重要，请记住）"><a href="#函数名、函数体和函数加载问题（重要，请记住）" class="headerlink" title="函数名、函数体和函数加载问题（重要，请记住）"></a>函数名、函数体和函数加载问题（重要，请记住）</h5><p>我们要记住：<strong>函数名 == 整个函数</strong>。举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log(fn) == console.log(function fn(){alert(1)});<br><br>//定义fn方法<br>function fn(){<br>    alert(1)<br>};<br></code></pre></td></tr></tbody></table></figure>

<p>我们知道，当我们在调用一个函数时，通常使用<code>函数()</code>这种格式；但此时，我们是直接使用<code>函数</code>这种格式，它的作用相当于整个函数。</p>
<p><strong>函数的加载问题</strong>：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。</p>
<h5 id="fn-和-fn-的区别【重要】"><a href="#fn-和-fn-的区别【重要】" class="headerlink" title="fn() 和 fn 的区别【重要】"></a>fn() 和 fn 的区别【重要】</h5><ul>
<li><code>fn()</code>：调用函数。相当于获取了函数的返回值。</li>
<li><code>fn</code>：函数对象。相当于直接获取了函数对象。</li>
</ul>
<h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><p>现有匿名函数如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">function(a, b) {<br>    console.log("a = " + a);<br>    console.log("b = " + b);<br>};<br></code></pre></td></tr></tbody></table></figure>

<p>立即执行函数如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">(function(a, b) {<br>    console.log("a = " + a);<br>    console.log("b = " + b);<br>})(123, 456);<br></code></pre></td></tr></tbody></table></figure>

<p>立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。</p>
<p>立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>函数也可以称为对象的属性。<strong>如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法</strong>。</p>
<p>调用这个函数就说调用对象的方法（method）。相比于方法，它只是名称上的区别，并没有其他的区别。</p>
<p>函数举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">// 调用函数<br>fn();<br></code></pre></td></tr></tbody></table></figure>

<p>方法举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">// 调用方法<br>obj.fn();<br></code></pre></td></tr></tbody></table></figure>

<p>我们可以这样说，如果直接是<code>fn()</code>，那就说明是函数调用。如果是发现<code>XX.fn()</code>的这种形式，那就说明是<strong>方法</strong>调用。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域指一个变量的作用范围。在js中，一共有两种作用域：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
</ul>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>直接编写在script标签中的JS代码，都在全局作用域。</p>
<ul>
<li>全局作用域在页面打开时创建，在页面关闭时销毁。</li>
<li>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。</li>
</ul>
<p>在全局作用域中：</p>
<ul>
<li>创建的<strong>变量</strong>都会作为window对象的属性保存。</li>
<li>创建的<strong>函数</strong>都会作为window对象的方法保存。</li>
</ul>
<p>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到。</p>
<h4 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h4><p><strong>对象的作用是：封装信息</strong>。比如Student类里可以封装学生的姓名、年龄、成绩等。</p>
<p>对象具有<strong>特征</strong>（属性）和<strong>行为</strong>（方法）。</p>
<p>面向对象：可以创建自定义的类型，很好的支持继承和多态。</p>
<p>面向对象的特征：封装、继承、多态。</p>
<h4 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h4><p>1.内置对象：</p>
<ul>
<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>
<li>比如：Math、String、Number、Boolean、Function、Object….</li>
</ul>
<p>2.宿主对象：</p>
<ul>
<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。</li>
<li>比如 BOM DOM。比如<code>console</code>、<code>document</code>。</li>
</ul>
<p>3.自定义对象：</p>
<ul>
<li>由开发人员自己创建的对象</li>
</ul>
<h4 id="对象的基本操作"><a href="#对象的基本操作" class="headerlink" title="对象的基本操作"></a>对象的基本操作</h4><p><strong>创建对象</strong></p>
<p>使用new关键字调用的函数，是构造函数constructor。<strong>构造函数是专门用来创建对象的函数</strong>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var obj = new Object();<br></code></pre></td></tr></tbody></table></figure>

<p>另外，使用<code>typeof</code>检查一个对象时，会返回<code>object</code>。</p>
<h4 id="向对象中添加属性"><a href="#向对象中添加属性" class="headerlink" title="向对象中添加属性"></a>向对象中添加属性</h4><p>在对象中保存的值称为属性。</p>
<p>向对象添加属性的语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">对象.属性名 = 属性值;<br></code></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var obj = new Object();<br><br>//向obj中添加一个name属性<br>obj.name = "孙悟空";<br><br>//向obj中添加一个gender属性<br>obj.gender = "男";<br><br>//向obj中添加一个age属性<br>obj.age = 18;<br><br>console.log(JSON.stringify(obj)); // 将 obj 以字符串的形式打印出来<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">{<br>    "name":"孙悟空",<br>    "gender":"男",<br>    "age":18<br>}<br></code></pre></td></tr></tbody></table></figure>





<h4 id="获取对象中的属性"><a href="#获取对象中的属性" class="headerlink" title="获取对象中的属性"></a>获取对象中的属性</h4><p><strong>方式1</strong>：</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">对象.属性名<br></code></pre></td></tr></tbody></table></figure>

<p><strong>方式2</strong>：可以使用<code>[]</code>这种形式去操作属性</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">对象["属性名"] = 属性值<br></code></pre></td></tr></tbody></table></figure>



<h4 id="修改对象的属性值"><a href="#修改对象的属性值" class="headerlink" title="修改对象的属性值"></a>修改对象的属性值</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">对象.属性名 = 新值<br>对象[属性名] = 新值<br></code></pre></td></tr></tbody></table></figure>



<h4 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">delete obj.name;<br>delete obj['name']<br></code></pre></td></tr></tbody></table></figure>



<h4 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h4><p>通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回true，没有则返回false。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">"属性名" in 对象<br>对象.hasOwnProperty('属性名')<br></code></pre></td></tr></tbody></table></figure>



<h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><p>如果要创建一个对象，我们可以使用下面这种方式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var obj = new Object();<br></code></pre></td></tr></tbody></table></figure>

<p>但是上面的这种方式，比较麻烦，我们还有更简洁的方式来创建一个对象。如下。</p>
<p>使用对象字面量来创建一个对象：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var obj = {};<br></code></pre></td></tr></tbody></table></figure>

<p>使用对象字面量，可以在创建对象时，直接指定对象中的属性。语法：{属性名:属性值,属性名:属性值….}</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var obj2 = {<br><br>    name: "猪八戒",<br>    age: 13,<br>    gender: "男",<br>    test: {<br>        name: "沙僧"<br>    },<br>    //我们还可以在对象中增加一个方法。以后可以通过obj2.sayName()的方式调用这个方法<br>    sayName: function(){<br>        console.log('smyhvae');<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>

<p>对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，则必须加引号。</p>
<h4 id="遍历对象中的属性：for-in"><a href="#遍历对象中的属性：for-in" class="headerlink" title="遍历对象中的属性：for in"></a>遍历对象中的属性：for in</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">for (var 变量 in 对象) {<br><br>}<br></code></pre></td></tr></tbody></table></figure>



<h4 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h4><p>我们首先记住一句话：JS中，所有的<strong>变量</strong>都是保存在<strong>栈内存</strong>中的。</p>
<p>然后来看看下面的区别。</p>
<p><strong>基本数据类型</strong>：</p>
<p>基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。</p>
<p><strong>引用数据类型</strong>：</p>
<p>对象是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而<strong>变量保存了对象的内存地址</strong>（对象的引用）。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的 上下文对象。</p>
<p>根据函数的调用方式的不同，this会指向不同的对象：【重要】</p>
<ul>
<li>1.以函数的形式调用时，this永远都是window。比如<code>fun();</code>相当于<code>window.fun();</code></li>
<li>2.以方法的形式调用时，this是调用方法的那个对象</li>
<li>3.以构造函数的形式调用时，this是新创建的那个对象</li>
<li>4.使用call和apply调用时，this是指定的那个对象</li>
</ul>
<p><strong>箭头函数中this的指向</strong></p>
<p>ES6中的箭头函数并不会使用上面四条标准的绑定规则，而是会继承外层函数调用的this绑定（无论this绑定到什么）。</p>
<h4 id="对象的创建-amp-构造函数"><a href="#对象的创建-amp-构造函数" class="headerlink" title="对象的创建&amp;构造函数"></a>对象的创建&amp;构造函数</h4><h5 id="方式一：对象字面量"><a href="#方式一：对象字面量" class="headerlink" title="方式一：对象字面量"></a>方式一：对象字面量</h5><p><strong>对象的字面量</strong>就是一个{}。里面的属性和方法均是<strong>键值对</strong>。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var o = {<br>            name: "生命壹号",<br>            age: 26,<br>            isBoy: true,<br>            sayHi: function() {<br>                console.log(this.name);<br>            }<br>        };<br><br>console.log(o);<br></code></pre></td></tr></tbody></table></figure>

<p>控制台输出：</p>
<p><img src="http://img.smyhvae.com/20180125_1834.png" alt="img"></p>
<h5 id="方式二：工厂模式"><a href="#方式二：工厂模式" class="headerlink" title="方式二：工厂模式"></a>方式二：工厂模式</h5><p>通过该方法可以大批量的创建对象。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">/*<br> * 使用工厂方法创建对象<br> *  通过该方法可以大批量的创建对象<br> */<br>function createPerson(name, age, gender) {<br>    //创建一个新的对象<br>    var obj = new Object();<br>    //向对象中添加属性<br>    obj.name = name;<br>    obj.age = age;<br>    obj.gender = gender;<br>    obj.sayName = function() {<br>        alert(this.name);<br>    };<br>    //将新的对象返回<br>    return obj;<br>}<br><br>var obj2 = createPerson("猪八戒", 28, "男");<br>var obj3 = createPerson("白骨精", 16, "女");<br>var obj4 = createPerson("蜘蛛精", 18, "女");<br></code></pre></td></tr></tbody></table></figure>

<p><strong>弊端：</strong></p>
<p>使用工厂方法创建的对象，使用的构造函数都是Object。<strong>所以创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象</strong>。</p>
<h5 id="方式三：利用构造函数"><a href="#方式三：利用构造函数" class="headerlink" title="方式三：利用构造函数"></a>方式三：利用构造函数</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">//利用构造函数自定义对象<br>var stu1 = new Student("smyh");<br>console.log(stu1);<br>stu1.sayHi();<br><br>var stu2 = new Student("vae");<br>console.log(stu2);<br>stu2.sayHi();<br><br><br>// 创建一个构造函数<br>function Student(name) {<br>    this.name = name;    //this指的是构造函数中的对象实例<br>    this.sayHi = function () {<br>        console.log(this.name + "厉害了");<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p><img src="http://img.smyhvae.com/20180125_1350.png" alt="img"></p>
<h4 id="构造函数和普通函数的区别"><a href="#构造函数和普通函数的区别" class="headerlink" title="构造函数和普通函数的区别"></a>构造函数和普通函数的区别</h4><p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。</p>
<p>构造函数和普通函数的区别就是<strong>调用方式</strong>的不同：普通函数是直接调用，而构造函数需要使用new关键字来调用。</p>
<p><strong>this的指向也有所不同</strong>：</p>
<ul>
<li>1.以函数的形式调用时，this永远都是window。比如<code>fun();</code>相当于<code>window.fun();</code></li>
<li>2.以方法的形式调用时，this是调用方法的那个对象</li>
<li>3.以构造函数的形式调用时，this是新创建的那个对象</li>
</ul>
<h4 id="new-一个构造函数的执行流程"><a href="#new-一个构造函数的执行流程" class="headerlink" title="new 一个构造函数的执行流程"></a>new 一个构造函数的执行流程</h4><p>（1）开辟内存空间，存储新创建的对象</p>
<p>（2）将新建的对象设置为构造函数中的this，在构造函数中可以使用this来引用 新建的对象</p>
<p>（3）执行函数中的代码（包括设置对象属性和方法等）</p>
<p>（4）将新建的对象作为返回值返回</p>
<h4 id="类、实例"><a href="#类、实例" class="headerlink" title="类、实例"></a>类、实例</h4><p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个<strong>类</strong>。</p>
<p>通过一个构造函数创建的对象，称为该类的<strong>实例</strong>。</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>使用 instanceof 可以检查<strong>一个对象是否为一个类的实例</strong>。</p>
<p><strong>语法如下</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">对象 instanceof 构造函数<br></code></pre></td></tr></tbody></table></figure>

<p>如果是，则返回true；否则返回false。</p>
<h4 id="json的介绍"><a href="#json的介绍" class="headerlink" title="json的介绍"></a>json的介绍</h4><blockquote>
<p>对象字面量和json比较像，这里我们对json做一个简单介绍。</p>
</blockquote>
<p>JSON：JavaScript Object Notation（JavaScript对象表示形式）。</p>
<p>JSON和对象字面量的区别：JSON的属性必须用双引号引号引起来，对象字面量可以省略。</p>
<p>json举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">{<br>      "name" : "zs",<br>      "age" : 18,<br>      "sex" : true,<br>      "sayHi" : function() {<br>          console.log(this.name);<br>      }<br>  };<br></code></pre></td></tr></tbody></table></figure>

<p>注：json里一般放常量、数组、对象等，但很少放function。</p>
<p>另外，对象和json没有长度，json.length的打印结果是undefined。于是乎，自然也就不能用for循环遍历（因为遍历时需要获取长度length）。</p>
<h5 id="json遍历的方法："><a href="#json遍历的方法：" class="headerlink" title="json遍历的方法："></a>json遍历的方法：</h5><p>json 采用 <code>for...in...</code>进行遍历，和数组的遍历方式不同。如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>    var myJson = {<br>        "name": "smyhvae",<br>        "aaa": 111,<br>        "bbb": 222<br>    };<br><br>    //json遍历的方法：for...in...<br>    for (var key in myJson) {<br>        console.log(key);   //获取 键<br>        console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）<br>        console.log("------");<br>    }<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>





<h5 id="原型prototype的概念"><a href="#原型prototype的概念" class="headerlink" title="原型prototype的概念"></a>原型prototype的概念</h5><p><strong>认识1</strong>：</p>
<p>我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。</p>
<p>如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">// 定义构造函数<br>function Person() {}<br><br>var per1 = new Person();<br>var per2 = new Person();<br><br>console.log(Person.prototype); // 打印结果：[object object]<br><br>console.log(per1.__proto__ == Person.prototype); // 打印结果：true<br></code></pre></td></tr></tbody></table></figure>

<p>上方代码的最后一行：打印结果表明，<code>实例.__proto__</code> 和 <code>构造函数.prototype</code>都指的是原型对象。</p>
<p><strong>认识2</strong>：</p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<p>以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。</p>
<p><strong>认识3</strong>：</p>
<p>使用 <code>in</code> 检查对象中是否含有某个属性时，如果对象中没有但是<strong>原型中</strong>有，也会返回true。</p>
<p>可以使用对象的<code>hasOwnProperty()</code>来检查<strong>对象自身中</strong>是否含有该属性。</p>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时：</p>
<ul>
<li>它会先在对象自身中寻找，如果有则直接使用；</li>
<li>如果没有则会去原型对象中寻找，如果找到则直接使用；</li>
<li>如果没有则去原型的原型中寻找，直到找到Object对象的原型。</li>
<li>Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null</li>
</ul>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, gender</span>) </span>{</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.name = name;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.age = age;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.gender = gender;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.init();</span><br><span class="javascript">    };</span><br><span class="javascript">    Person.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">'123123'</span>;</span><br><span class="javascript">    }</span><br><span class="javascript"></span><br><span class="javascript">    Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="javascript">        <span class="hljs-keyword">return</span> (</span><br><span class="javascript">            <span class="hljs-string">"Person[name="</span> +</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.name +</span><br><span class="javascript">            <span class="hljs-string">",age="</span> +</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.age +</span><br><span class="javascript">            <span class="hljs-string">",gender="</span> +</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.gender +</span><br><span class="javascript">            <span class="hljs-string">"]"</span></span><br><span class="javascript">        );</span><br><span class="javascript">    };</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> per1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"vae"</span>, <span class="hljs-number">26</span>, <span class="hljs-string">"男"</span>)</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(per1);</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"per1 = "</span> + per1)</span><br><span class="javascript">    <span class="hljs-comment">//在设置toString的时候 因为会重写toString方法</span></span><br><span class="javascript">    <span class="hljs-comment">// 设置 init的时候 会在原型链重新构成一个 方法 在开始的时候调用它 对象会调用原型链上面的方法。</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>



<h5 id="JS的垃圾回收（GC）机制"><a href="#JS的垃圾回收（GC）机制" class="headerlink" title="JS的垃圾回收（GC）机制"></a>JS的垃圾回收（GC）机制</h5><p>程序运行过程中会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢。所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾。</p>
<p>当一个对象没有任何的变量或属性对它进行引用时，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</p>
<p>上面这句话，也可以这样理解：如果堆内存中的对象，没有任何变量指向它时，这个堆内存里的对象就会成为垃圾。</p>
<p>JS拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁。我们不需要也不能进行垃圾回收的操作。我们仅仅需要做的是：如果你不再使用该对象，那么，将改对象的引用设置为 null 即可。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>方式一</strong>：字面量定义。举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1,2,3];<br></code></pre></td></tr></tbody></table></figure>

<p><strong>方式二</strong>：对象定义（数组的构造函数）。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = new Array(参数);<br></code></pre></td></tr></tbody></table></figure>



<h4 id="向数组中添加元素"><a href="#向数组中添加元素" class="headerlink" title="向数组中添加元素"></a>向数组中添加元素</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组[索引] = 值<br></code></pre></td></tr></tbody></table></figure>



<h4 id="获取数组中的元素"><a href="#获取数组中的元素" class="headerlink" title="获取数组中的元素"></a>获取数组中的元素</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组[索引]<br></code></pre></td></tr></tbody></table></figure>



<h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><p>可以使用<code>length</code>属性来获取数组的长度(元素的个数)。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组的长度 = 数组名.length；<br></code></pre></td></tr></tbody></table></figure>



<h4 id="修改数组的长度（修改length）"><a href="#修改数组的长度（修改length）" class="headerlink" title="修改数组的长度（修改length）"></a>修改数组的长度（修改length）</h4><ul>
<li>如果修改的length大于原长度，则多出部分会空出来，置为 null。</li>
<li>如果修改的length小于原长度，则多出的元素会被删除，数组将从后面删除元素。</li>
<li>（特例：伪数组arguments的长度可以修改，但是不能修改里面的元素）</li>
</ul>
<p><strong>数组的四个基本方法如下</strong>：（数组元素的添加和删除）</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">push()</td>
<td align="left">向数组的<strong>最后面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">pop()</td>
<td align="left">删除数组中的<strong>最后一个</strong>元素，返回结果为<strong>被删除的元素</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">unshift()</td>
<td align="left">在数组<strong>最前面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">shift()</td>
<td align="left">删除数组中的<strong>第一个</strong>元素，返回结果为<strong>被删除的元素</strong></td>
<td align="left">会改变原数组</td>
</tr>
</tbody></table>
<p><strong>数组的常见方法如下</strong>：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">slice()</td>
<td align="left">从数组中<strong>提取</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">splice()</td>
<td align="left">从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">concat()</td>
<td align="left">连接两个或多个数组，返回结果为<strong>新的数组</strong></td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">join()</td>
<td align="left">将数组转换为字符串，返回结果为<strong>转换后的字符串</strong></td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">reverse()</td>
<td align="left">反转数组，返回结果为<strong>反转后的数组</strong></td>
<td align="left">会改变原数组</td>
</tr>
<tr>
<td align="left">sort()</td>
<td align="left">对数组的元素,默认按照<strong>Unicode编码</strong>，从小到大进行排序</td>
<td align="left">会改变原数组</td>
</tr>
</tbody></table>
<p><strong>遍历数组的方法如下</strong>：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for循环</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">forEach()</td>
<td align="left">和 for循环类似，但需要兼容IE8以上</td>
<td align="left">forEach() 没有返回值。也就是说，它的返回值是 undefined</td>
</tr>
<tr>
<td align="left">map()</td>
<td align="left">对原数组中的每一项进行加工，将组成新的数组</td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">filter()</td>
<td align="left">对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组，返回结果为<strong>新的数组</strong>。可以起到过滤的作用</td>
<td align="left">不会改变原数组</td>
</tr>
<tr>
<td align="left">every()</td>
<td align="left">如果有一项返回false，则停止遍历，此方法返回 false</td>
<td align="left">一假即假。要求每一项都返回true，最终的结果才返回true</td>
</tr>
<tr>
<td align="left">some()</td>
<td align="left">只要有一项返回true，则停止遍历，此方法返回true</td>
<td align="left">一真即真。要求每一项都返回false，最终的结果才返回false</td>
</tr>
<tr>
<td align="left">reduce</td>
<td align="left">为数组中的每一个元素，依次执行回调函数</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>数组的其他方法如下</strong>：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">indexOf(value)</td>
<td align="left">从前往后索引，获取 value 在数组中的第一个下标</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lastIndexOf(value)</td>
<td align="left">从后往前索引，获取 value 在数组中的最后一个下标</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">find(function())</td>
<td align="left">找出<strong>第一个</strong>满足「指定条件返回true」的元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">findIndex(function())</td>
<td align="left">找出<strong>第一个</strong>满足「指定条件返回true」的元素的index</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Array.from(arrayLike)</td>
<td align="left">将<strong>伪数组</strong>转化为<strong>真数组</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Array.of(value1, value2, value3)</td>
<td align="left">将<strong>一系列值</strong>转换成数组。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p><code>push()</code>：向数组的<strong>最后面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组的新长度 = 数组.push(元素);<br></code></pre></td></tr></tbody></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["王一", "王二", "王三"];<br><br>var result1 = arr.push("王四"); // 末尾插入一个元素<br>var result2 = arr.push("王五", "王六"); // 末尾插入多个元素<br><br>console.log(result1); // 打印结果：4<br>console.log(result2); // 打印结果：6<br>console.log(JSON.stringify(arr)); // 打印结果：["王一","王二","王三","王四","王五","王六"]<br><br></code></pre></td></tr></tbody></table></figure>

<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p><code>pop()</code>：删除数组中的<strong>最后一个</strong>元素，返回结果为<strong>被删除的元素</strong>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">被删除的元素 = 数组.pop();<br></code></pre></td></tr></tbody></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["王一", "王二", "王三"];<br><br>var result1 = arr.pop();<br><br>console.log(result1); // 打印结果：王三<br>console.log(JSON.stringify(arr)); // 打印结果：["王一","王二"]<br></code></pre></td></tr></tbody></table></figure>



<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p><code>unshift()</code>：在数组<strong>最前面</strong>插入一个或多个元素，返回结果为<strong>该数组新的长度</strong>。插入元素后，其他元素的索引会依次调整。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组的新长度 = 数组.unshift(元素);<br></code></pre></td></tr></tbody></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["王一", "王二", "王三"];<br><br>var result1 = arr.unshift("王四"); // 最前面插入一个元素<br>var result2 = arr.unshift("王五", "王六"); // 最前面插入多个元素<br><br>console.log(result1); // 打印结果：4<br>console.log(result2); // 打印结果：6<br>console.log(JSON.stringify(arr)); // 打印结果：["王五","王六","王四","王一","王二","王三"]<br><br></code></pre></td></tr></tbody></table></figure>



<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p><code>shift()</code>：删除数组中的<strong>第一个</strong>元素，返回结果为<strong>被删除的元素</strong>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">被删除的元素 = 数组.shift();<br></code></pre></td></tr></tbody></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["王一", "王二", "王三"];<br><br>var result1 = arr.shift();<br><br>console.log(result1); // 打印结果：王一<br>console.log(JSON.stringify(arr)); // 打印结果：["王二","王三"]<br></code></pre></td></tr></tbody></table></figure>



<h3 id="数组的常见方法"><a href="#数组的常见方法" class="headerlink" title="数组的常见方法"></a>数组的常见方法</h3><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p><code>slice()</code>：从数组中<strong>提取</strong>指定的一个或者多个元素，返回结果为<strong>新的数组</strong>（不会改变原来的数组）。</p>
<p>备注：该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">新数组 = 原数组.slice(开始位置的索引, 结束位置的索引);    //注意：包含开始索引，不包含结束索引<br></code></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["a", "b", "c", "d", "e", "f"];<br><br>var result1 = arr.slice(2); //从第二个值开始提取<br>var result2 = arr.slice(-2); //提取最后两个元素<br>var result3 = arr.slice(2, 4); //提取从第二个到第四个之间的值（不包括第四个值）<br>var result4 = arr.slice(4, 2); //空<br><br>console.log("arr:" + JSON.stringify(arr));<br>console.log("result1:" + JSON.stringify(result1));<br>console.log("result2:" + JSON.stringify(result2));<br>console.log("result3:" + JSON.stringify(result3));<br>console.log("result4:" + JSON.stringify(result4));<br><br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr:["a","b","c","d","e","f"]<br>result1:["c","d","e","f"]<br>result2:["e","f"]<br>result3:["c","d"]<br>result4:[]<br></code></pre></td></tr></tbody></table></figure>

<p><strong>补充</strong>：</p>
<p>很多前端开发人员会用 slice()将伪数组，转化为真数组。写法如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">array = Array.prototye.slice.call(arrayLike)<br>或者<br>array = [].slice.call(arrayLike)<br></code></pre></td></tr></tbody></table></figure>

<p>ES6 看不下去这种蹩脚的转化方法，于是出了一个新的 API：（专门用来将伪数组转化成真数组）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">array = Array.from(arrayLike)<br></code></pre></td></tr></tbody></table></figure>



<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p><code>splice()</code>：从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong>（会改变原来的数组）。</p>
<p>备注：该方法会改变原数组，会将指定元素从原数组中删除；被删除的元素会封装到一个新的数组中返回。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">新数组 = 原数组.splice(起始索引index, 需要删除的个数, 第三个参数, 第四个参数...);<br></code></pre></td></tr></tbody></table></figure>

<p>上方语法中，第三个及之后的参数，表示：向原数组中添加新的元素，这些元素将会自动插入到开始位置索引的前面。</p>
<p>举例1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr1 = ["a", "b", "c", "d", "e", "f"];<br>var result1 = arr1.splice(1); //从第index为1的位置开始，删除元素<br><br>console.log("arr1：" + JSON.stringify(arr1));<br>console.log("result1：" + JSON.stringify(result1));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr1：["a"]<br>result1：["b","c","d","e","f"]<br></code></pre></td></tr></tbody></table></figure>

<p>举例2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr2 = ["a", "b", "c", "d", "e", "f"];<br>var result2 = arr2.splice(-2); //删除最后两个元素<br><br>console.log("arr2：" + JSON.stringify(arr2));<br>console.log("result2：" + JSON.stringify(result2));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr2：["a","b","c","d"]<br>result2：["e","f"]<br></code></pre></td></tr></tbody></table></figure>

<p>举例3：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr3 = ["a", "b", "c", "d", "e", "f"];<br>var result3 = arr3.splice(1, 3); //从第index为1的位置开始删除元素,一共删除三个元素<br><br>console.log("arr3：" + JSON.stringify(arr3));<br>console.log("result3：" + JSON.stringify(result3));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr3：["a","e","f"]<br>result3：["b","c","d"]<br></code></pre></td></tr></tbody></table></figure>

<p>举例4：（我们来看看<strong>第三个参数</strong>的用法）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr4 = ["a", "b", "c", "d", "e", "f"];<br><br>//从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素<br>var result4 = arr4.splice(1, 3, "千古壹号", "vae");<br><br>console.log("arr4：" + JSON.stringify(arr4));<br>console.log("result4：" + JSON.stringify(result4));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr4：["a","千古壹号","vae","e","f"]<br>result4：["b","c","d"]<br></code></pre></td></tr></tbody></table></figure>



<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p><code>concat()</code>：连接两个或多个数组，返回结果为<strong>新的数组</strong>。（不会改变原数组）</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">新数组 = 数组1.concat(数组2, 数组3 ...);<br><br></code></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr1 = [1, 2, 3];<br>var arr2 = ["a", "b", "c"];<br>var arr3 = ["千古壹号", "vae"];<br><br>var result1 = arr1.concat(arr2);<br><br>var result2 = arr2.concat(arr1, arr3);<br><br>console.log("arr1 =" + JSON.stringify(arr1));<br>console.log("arr2 =" + JSON.stringify(arr2));<br>console.log("arr3 =" + JSON.stringify(arr3));<br><br>console.log("result1 =" + JSON.stringify(result1));<br>console.log("result2 =" + JSON.stringify(result2));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr1 =[1,2,3]<br>arr2 =["a","b","c"]<br>arr3 =["千古壹号","vae"]<br><br>result1 =[1,2,3,"a","b","c"]<br>result2 =["a","b","c",1,2,3,"千古壹号","vae"]<br></code></pre></td></tr></tbody></table></figure>

<p>从打印结果中可以看到，原数组并没有被修改。</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p><code>join()</code>：将数组转换为字符串，返回结果为<strong>转换后的字符串</strong>（不会改变原来的数组）。</p>
<p>补充：<code>join()</code>方法可以指定一个<strong>字符串</strong>作为参数，这个字符串将会成为数组中元素的<strong>连接符</strong>；如果不指定连接符，则默认使用 <code>,</code> 作为连接符，此时和 <code>toString()的效果是一致的</code>。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">新的字符串 = 原数组.join(参数); // 参数选填<br></code></pre></td></tr></tbody></table></figure>

<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["a", "b", "c"];<br><br>var result1 = arr.join(); // 这里没有指定连接符，所以默认使用 , 作为连接符<br><br>var result2 = arr.join("-"); // 使用指定的字符串作为连接符<br><br>console.log(typeof arr); // 打印结果：object<br>console.log(typeof result1); // 打印结果：string<br><br>console.log("arr =" + JSON.stringify(arr));<br>console.log("result1 =" + JSON.stringify(result1));<br>console.log("result2 =" + JSON.stringify(result2));<br><br></code></pre></td></tr></tbody></table></figure>

<p>上方代码中，最后三行的打印结果是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr =["a","b","c"]<br>result1 =a,b,c<br>result2 =a-b-c<br></code></pre></td></tr></tbody></table></figure>



<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p><code>reverse()</code>：反转数组，返回结果为<strong>反转后的数组</strong>（会改变原来的数组）。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">反转后的数组  =  数组.reverse();<br></code></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["a", "b", "c", "d", "e", "f"];<br><br>var result = arr.reverse(); // 将数组 arr 进行反转<br><br>console.log("arr =" + JSON.stringify(arr));<br>console.log("result =" + JSON.stringify(result));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr =["f","e","d","c","b","a"]<br>result =["f","e","d","c","b","a"]<br></code></pre></td></tr></tbody></table></figure>

<p>从打印结果可以看出，原来的数组已经被改变了。</p>
<h4 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a>sort()方法</h4><blockquote>
<p>sort()方法要好好理解。所以，我们单独用一大段来讲。</p>
</blockquote>
<p><code>sort()</code>：对数组的元素进行从小到大来排序（会改变原来的数组）。</p>
<h3 id="sort-方法举例：无参时"><a href="#sort-方法举例：无参时" class="headerlink" title="sort()方法举例：无参时"></a>sort()方法举例：无参时</h3><p>如果在使用 sort() 方法时不带参，则默认按照<strong>Unicode编码</strong>，从小到大进行排序。</p>
<p><strong>举例1</strong>：（当数组中的元素为字符串时）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr1 = ["e", "b", "d", "a", "f", "c"];<br><br>var result = arr1.sort(); // 将数组 arr1 进行排序<br><br>console.log("arr1 =" + JSON.stringify(arr1));<br>console.log("result =" + JSON.stringify(result));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr1 =["a","b","c","d","e","f"]<br>result =["a","b","c","d","e","f"]<br></code></pre></td></tr></tbody></table></figure>

<p><strong>举例2</strong>：（当数组中的元素为数字时）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr2 = [5, 2, 11, 3, 4, 1];<br><br>var result = arr2.sort(); // 将数组 arr2 进行排序<br><br>console.log("arr2 =" + JSON.stringify(arr2));<br>console.log("result =" + JSON.stringify(result));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr2 =[1,11,2,3,4,5]<br>result =[1,11,2,3,4,5]<br></code></pre></td></tr></tbody></table></figure>

<p>上方的打印结果中，你会发现，使用 sort() 排序后，数字<code>11</code>竟然在数字<code>2</code>的前面。这是为啥呢？因为上面讲到了，<code>sort()</code>方法是按照<strong>Unicode编码</strong>进行排序的。</p>
<p>那如果我想让 arr2 里的数字，完全按照从小到大排序，怎么操作呢？继续往下看。</p>
<h4 id="sort-方法举例：带参时"><a href="#sort-方法举例：带参时" class="headerlink" title="sort()方法举例：带参时"></a>sort()方法举例：带参时</h4><p>如果在 sort()方法中带参，我们就可以<strong>自定义</strong>排序规则。具体做法如下：</p>
<p>我们可以在sort()添加一个回调函数，来指定排序规则。回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数</p>
<p>浏览器根据回调函数的返回值来决定元素的排序：（重要）</p>
<ul>
<li>如果返回一个大于0的值，则元素会交换位置</li>
<li>如果返回一个小于0的值，则元素位置不变</li>
<li>如果返回一个0，则认为两个元素相等，则不交换位置</li>
</ul>
<p><strong>代码举例</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr3 = [5, 2, 11, 3, 4, 1];<br><br>// 自定义排序规则<br>var result = arr3.sort(function(a, b) {<br>if (a &gt; b) { // 如果 a 大于 b，则交换 a 和 b 的位置<br>  return 1;<br>} else if (a &lt; b) { // 如果 a 小于 b，则位置不变<br>  return -1;<br>} else { // 如果 a 等于 b，则位置不变<br>  return 0;<br>}<br>});<br><br>console.log("arr3 =" + JSON.stringify(arr3));<br>console.log("result =" + JSON.stringify(result));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr3 =[1,2,3,4,5,11]<br>result =[1,2,3,4,5,11]<br></code></pre></td></tr></tbody></table></figure>

<p>上方代码的写法太啰嗦了，其实也可以简化为如下写法：</p>
<p><strong>代码优化</strong>：（冒泡排序）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr3 = [5, 2, 11, 3, 4, 1];<br><br>// 自定义排序规则<br>var result = arr3.sort(function(a, b) {<br>return a - b; // 升序排列<br>// return b - a; // 降序排列<br>});<br><br>console.log("arr3 =" + JSON.stringify(arr3));<br>console.log("result =" + JSON.stringify(result));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr3 =[1,2,3,4,5,11]<br>result =[1,2,3,4,5,11]<br></code></pre></td></tr></tbody></table></figure>



<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><p>遍历数组即：获取并操作数组中的每一个元素。在我们的实战开发中，使用得非常频繁。</p>
<p>遍历数组的方法包括：every()、filter()、forEach()、map()、some()</p>
<p>PS：这几个方法<strong>不会修改原数组</strong>。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组/boolean/无 = 数组.every/filter/forEach/map/some(<br>                        function(item, index, arr){<br>                                        程序和返回值；<br>                        })<br></code></pre></td></tr></tbody></table></figure>

<p>有了这几种方法，就可以替代一些for循环了。下面依次来介绍。</p>
<h4 id="for循环-遍历"><a href="#for循环-遍历" class="headerlink" title="for循环 遍历"></a>for循环 遍历</h4><p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["生命壹号","许嵩","永不止步"];<br>for(var i = 0;i&lt;arr.length;i++){<br>    console.log(arr[i]);  // arr[i]代表的是数组中的每一个元素i<br>}<br><br>console.log(arr);<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180124_2008.png" alt="img"></p>
<h4 id="forEach-遍历"><a href="#forEach-遍历" class="headerlink" title="forEach() 遍历"></a>forEach() 遍历</h4><blockquote>
<p><code>forEach()</code> 这种遍历方法只支持IE8以上的浏览器。IE8及以下的浏览器均不支持该方法。所以如果需要兼容IE8，则不要使用forEach，改为使用for循环来遍历即可。</p>
</blockquote>
<p>forEach()方法需要一个函数作为参数。这种函数，是由我们创建但是不由我们调用的，我们称为回调函数。</p>
<p>数组中有几个元素，该回调函数就会执行几次。执行完毕后，浏览器会将遍历到的元素。</p>
<p>回调函数中传递三个参数：</p>
<ul>
<li>第一个参数，就是当前正在遍历的元素</li>
<li>第二个参数，就是当前正在遍历的元素的索引</li>
<li>第三个参数，就是正在遍历的数组</li>
</ul>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["王一", "王二", "王三"];<br><br>arr.forEach(function(item, index, obj) {<br>console.log("item:" + item);<br>console.log("index:" + index);<br>console.log("obj:" + obj);<br>console.log("----------");<br>});<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">item:王一<br>index:0<br>obj:王一,王二,王三<br>----------<br><br>item:王二<br>index:1<br>obj:王一,王二,王三<br>----------<br><br>item:王三<br>index:2<br>obj:王一,王二,王三<br>----------<br></code></pre></td></tr></tbody></table></figure>

<p>注意，forEach() 的返回值是 undefined。也就是说，它没有返回值。如果你尝试 <code>tempArry = arr.forEach()</code>这种方式来接收，是达不到效果的。</p>
<h4 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h4><p>解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是<strong>加工之后</strong>的新数组）。</p>
<p><strong>举例1</strong>：（拷贝的过程中改变数组元素的值）</p>
<p>有一个已知的数组arr1，我要求让arr1中的每个元素的值都加10，这里就可以用到 map 方法。代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr1 = [1, 3, 6, 2, 5, 6];<br><br>var arr2 = arr1.map(function (item, index) {<br>    return item + 10;  //让arr1中的每个元素加10<br><br>})<br>console.log(arr2);<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180402_0938.png" alt="img"></p>
<p><strong>举例2</strong>：【重要案例】</p>
<p>将A数组中某个属性的值，存储到B数组中。代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">const arr1 = [<br>    { name: '千古壹号', age: '28' }, { name: '许嵩', age: '32' }<br>];<br>const arr2 = arr1.map(item =&gt; item.name); // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中<br><br>console.log('arr1:' + JSON.stringify(arr1));<br>console.log('arr2:' + JSON.stringify(arr2));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr1:[{"name":"千古壹号","age":"28"},{"name":"许嵩","age":"32"}]<br><br>arr2:["千古壹号","许嵩"]<br><br></code></pre></td></tr></tbody></table></figure>

<p>map的应用场景，主要就是以上两种。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>解释：对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组（返回值就是这个新的数组）。</p>
<p><strong>举例1</strong>：找出数组 arr1 中大于4的元素，返回一个新的数组。代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr1 = [1, 3, 6, 2, 5, 6];<br><br>var arr2 = arr1.filter(function(item, index) {<br>    return item &gt; 4; //将arr1中大于4的元素返回，组成新的数组<br>});<br>console.log(JSON.stringify(arr2));<br><br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">[6,5,6]<br></code></pre></td></tr></tbody></table></figure>

<p>上方代码的ES6写法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">const arr1 = [1, 3, 6, 2, 5, 6];<br><br>const arr2 = arr1.filter(item=&gt; item &gt; 4); //将arr1中大于4的元素返回，组成新的数组<br><br>console.log(JSON.stringify(arr2));<br><br></code></pre></td></tr></tbody></table></figure>

<p><strong>举例2</strong>：</p>
<p>获取数组A中指定类型的对象，放到数组B中。代码举例如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">const arr1 = [<br>    { name: '许嵩', type: '一线' },<br>    { name: '周杰伦', type: '过气' },<br>    { name: '邓紫棋', type: '一线' },<br>];<br><br>const arr2 = arr1.filter(item =&gt; item.type == '一线'); // 筛选出一线歌手<br><br>console.log(JSON.stringify(arr2));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">[{"name":"许嵩","type":"一线"},{"name":"邓紫棋","type":"一线"}]<br></code></pre></td></tr></tbody></table></figure>



<h4 id="every-方法"><a href="#every-方法" class="headerlink" title="every()方法"></a>every()方法</h4><p><code>every()</code>：对数组中每一项运行回调函数，如果都返回true，every就返回true；如果有一项返回false，则停止遍历，此方法返回false。</p>
<p>注意：every()方法的返回值是boolean值，参数是回调函数。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr1 = ["千古", "宿敌", "南山忆", "素颜"];<br>var bool1 = arr1.every(function (element, index, array) {<br>    if (element.length &gt; 2) {<br>        return false;<br>    }<br>    return true;<br>});<br>console.log(bool1);  //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false<br><br>var arr2 = ["千古", "宿敌", "南山", "素颜"];<br>var bool2 = arr2.every(function (element, index, array) {<br>    if (element.length &gt; 2) {<br>        return false;<br>    }<br>    return true;<br>});<br>console.log(bool2);  //输出结果：true。因为每个元素的长度都是两个字符。<br></code></pre></td></tr></tbody></table></figure>



<h4 id="some-方法"><a href="#some-方法" class="headerlink" title="some()方法"></a>some()方法</h4><p><code>some()</code>：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。</p>
<p>注意：some()方法的返回值是boolean值。</p>
<h4 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce()方法"></a>reduce()方法</h4><blockquote>
<p>reduce的发音：[rɪ’djuːs]。中文含义是减少。</p>
</blockquote>
<p><code>reduce()</code>：为数组中的每一个元素，依次执行回调函数。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">arr.reduce(<br>    function(previousValue, item, index, arr) {<br><br>    }, initialValue)<br><br></code></pre></td></tr></tbody></table></figure>

<p>参数解释：</p>
<ul>
<li>previousValue：上一次调用回调函数时的返回值，或者初始值</li>
<li>currentValue：当前正在处理的数组元素</li>
<li>currentIndex：当前正在处理的数组元素下标</li>
<li>array：调用reduce()方法的数组</li>
<li>initialValue：可选的初始值（作为第一次调用回调函数时传给 previousValue 的值）</li>
</ul>
<p>备注：如果能熟练使用 reduce 的用法，将能替代很多其他的数组方法。</p>
<p><strong>举例1</strong>：</p>
<p>计算数组中所有元素项的总和。代码实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = [2, 0, 1, 9, 6];<br>sumValue = arr.reduce(function(total, item) { //  计算 arr 数组中，所有元素项的综合<br>    return total + item;<br>}, 0);<br><br>console.log('sumValue:' + sumValue); // 打印结果：18<br></code></pre></td></tr></tbody></table></figure>



<h4 id="数组的其他方法"><a href="#数组的其他方法" class="headerlink" title="数组的其他方法"></a>数组的其他方法</h4><h3 id="indexOf-和-lastIndexOf-：获取数据的索引"><a href="#indexOf-和-lastIndexOf-：获取数据的索引" class="headerlink" title="indexOf() 和 lastIndexOf()：获取数据的索引"></a>indexOf() 和 lastIndexOf()：获取数据的索引</h3><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">索引值 = 数组.indexOf(value);<br><br>索引值 = 数组.lastIndexOf(value);<br></code></pre></td></tr></tbody></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>indexOf(value)：从前往后索引，获取 value 在数组中的第一个下标。</li>
<li>lastIndexOf(value) ：从后往前索引，获取 value 在数组中的最后一个下标。</li>
</ul>
<p><strong>作用</strong>：</p>
<p>利用这个方法，我们可以判断某个值是否在指定的数组中。**如果没找到则返回<code>-1</code>**。</p>
<p> <strong>举例1</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["a","b","c","d","e","d","c"];<br><br>console.log(arr.indexOf("c"));       //从前往后，找第一个"c"在哪个位置<br>console.log(arr.lastIndexOf("d"));   //从后往前，找第一个"d"在哪个位置<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180126_1125.png" alt="img"></p>
<p><strong>举例2</strong>：判断某个值是否在数组中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var arr = ["29926392220", "29965620629", "28003663436", " ", "28818504366"];<br><br>var str = [<br>    {name:"smyh", id: "12334"},<br><br>    {name:"vae", id: "28818504366"}<br>];<br><br>str.filter(item =&gt; {<br>    console.log(arr.indexOf(item.id));<br>})<br><br></code></pre></td></tr></tbody></table></figure>



<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">find(function(item, index, arr){return true})<br></code></pre></td></tr></tbody></table></figure>

<p><strong>作用</strong>：找出<strong>第一个</strong>满足「指定条件返回true」的元素。</p>
<p>备注：一旦找到符合条件的第一个元素，将不再继续往下遍历。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">let arr = [2, 3, 2, 5, 7, 6];<br><br>let result = arr.find(function (item, index) {<br>    return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回<br>});<br><br>console.log(result);  //打印结果：5<br></code></pre></td></tr></tbody></table></figure>



<h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">findIndex(function(item, index, arr){return true})<br></code></pre></td></tr></tbody></table></figure>

<p><strong>作用</strong>：找出<strong>第一个</strong>满足「指定条件返回true」的元素的index。</p>
<p>举例：</p>
<blockquote>
<p>我们直接把上面的代码中的find方法改成findIndex，来看看效果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">let arr = [2, 3, 2, 5, 7, 6];<br><br>let result = arr.findIndex(function (item, index) {<br>    return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素的index返回<br>});<br><br>console.log(result); //打印结果：3<br></code></pre></td></tr></tbody></table></figure>



<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">array = Array.from(arrayLike)<br></code></pre></td></tr></tbody></table></figure>

<p><strong>作用</strong>：将<strong>伪数组</strong>或可遍历对象转换为<strong>真数组</strong>。</p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;body&gt;<br>&lt;button&gt;按钮1&lt;/button&gt;<br>&lt;button&gt;按钮2&lt;/button&gt;<br>&lt;button&gt;按钮3&lt;/button&gt;<br><br>&lt;script&gt;<br>    let btnArray = document.getElementsByTagName('button');<br>    console.log(btnArray);<br>    console.log(btnArray[0]);<br><br>&lt;/script&gt;<br><br>&lt;/body&gt;<br><br></code></pre></td></tr></tbody></table></figure>

<p>上面的布局中，有三个button标签，我们通过<code>getElementsByTagName</code>获取到的<code>btnArray</code>实际上是<strong>伪数组</strong>，并不是真实的数组：</p>
<p><img src="http://img.smyhvae.com/20180402_1116.png" alt="img"></p>
<p>既然<code>btnArray</code>是伪数组，它就不能使用数组的一般方法，否则会报错：</p>
<p><img src="http://img.smyhvae.com/20180402_1121.png" alt="img"></p>
<p>解决办法：采用<code>Array.from</code>方法将<code>btnArray</code>这个伪数组转换为真数组即可：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">Array.from(btnArray);<br></code></pre></td></tr></tbody></table></figure>

<p>然后就可以使用数组的一般方法了：</p>
<p><img src="http://img.smyhvae.com/20180402_1125.png" alt="img"></p>
<p><strong>伪数组与真数组的区别</strong>：</p>
<p>伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有 pop、join等属性。</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">Array.of(value1, value2, value3)<br></code></pre></td></tr></tbody></table></figure>

<p><strong>作用</strong>：将一系列值转换成数组。</p>
<p><strong>举例</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">let arr = Array.of(1, 'abc', true);<br>console.log(arr);<br></code></pre></td></tr></tbody></table></figure>



<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="isArray-：判断是否为数组"><a href="#isArray-：判断是否为数组" class="headerlink" title="isArray()：判断是否为数组"></a>isArray()：判断是否为数组</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">布尔值 = Array.isArray(被检测的值) ;<br></code></pre></td></tr></tbody></table></figure>

<p>以前，我们会通过 <code>A instanceof B</code>来判断 A 是否属于 B 类型。但是在数组里，这种 instanceof 方法已经用的不多了，因为有下面isArray()方法。</p>
<h4 id="toString-：转换数组"><a href="#toString-：转换数组" class="headerlink" title="toString()：转换数组"></a>toString()：转换数组</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">字符串 = 数组.toString();<br></code></pre></td></tr></tbody></table></figure>

<p>解释：把数组转换成字符串，每一项用<code>,</code>分割。</p>
<h4 id="valueOf-：返回数组本身"><a href="#valueOf-：返回数组本身" class="headerlink" title="valueOf()：返回数组本身"></a>valueOf()：返回数组本身</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">数组本身 = 数组.valueOf();<br></code></pre></td></tr></tbody></table></figure>

<p>这个方法的意义不大。因为我们指直接写数组对象的名字，就已经是数组本身了。</p>
<h3 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h3><h3 id="splice-练习：数组去重"><a href="#splice-练习：数组去重" class="headerlink" title="splice()练习：数组去重"></a>splice()练习：数组去重</h3><p>代码实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">//创建一个数组<br>var arr = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5];<br><br>//去除数组中重复的数字<br>//获取数组中的每一个元素<br>for (var i = 0; i &lt; arr.length; i++) {<br>  //console.log(arr[i]);<br>  /*获取当前元素后的所有元素*/<br>  for (var j = i + 1; j &lt; arr.length; j++) {<br>    //console.log("----&gt;"+arr[j]);<br>    //判断两个元素的值是否相等<br>    if (arr[i] == arr[j]) {<br>      //如果相等则证明出现了重复的元素，则删除j对应的元素<br>      arr.splice(j, 1);<br>      //当删除了当前j所在的元素以后，后边的元素会自动补位<br>      //此时将不会在比较这个元素吧，我需要在比较一次j所在位置的元素<br>      //使j自减<br>      j--;<br>    }<br>  }<br>}<br><br>console.log(arr);<br></code></pre></td></tr></tbody></table></figure>

<h3 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h3><p>清空数组，有以下几种方式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var array = [1,2,3,4,5,6];<br><br>array.splice(0);      //方式1：删除数组中所有项目<br>array.length = 0;     //方式2：length属性可以赋值，在其它语言中length是只读<br>array = [];           //方式3：推荐<br></code></pre></td></tr></tbody></table></figure>



<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h3 id="包装类的介绍"><a href="#包装类的介绍" class="headerlink" title="包装类的介绍"></a>包装类的介绍</h3><p>我们都知道，js中的数据类型包括以下几种。</p>
<ul>
<li>基本数据类型：String、Number、Boolean、Null、Undefined</li>
<li>引用数据类型：Object</li>
</ul>
<p>JS为我们提供了<strong>三个包装类</strong>：</p>
<ul>
<li>String()：将基本数据类型字符串，转换为String对象。</li>
<li>Number()：将基本数据类型的数字，转换为Number对象。</li>
<li>Boolean()：将基本数据类型的布尔值，转换为Boolean对象。</li>
</ul>
<p>通过上面这这三个包装类，我们可以<strong>将基本数据类型的数据转换为对象</strong>。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var num = new Number(3);<br><br>var str = new String("hello");<br><br>var bool = new Boolean(true);<br><br>console.log(typeof num); // 打印结果：object<br></code></pre></td></tr></tbody></table></figure>

<p><strong>需要注意的是</strong>：我们在实际应用中不会使用基本数据类型的对象。如果使用基本数据类型的对象，在做一些比较时可能会带来一些<strong>不可预期</strong>的结果。</p>
<h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p><strong>节点</strong>（Node）：构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。</p>
<p>虽然都是节点，但是实际上他们的具体类型是不同的。常见节点分为四类：</p>
<ul>
<li>文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。</li>
<li>元素节点（标签）：HTML标签。</li>
<li>属性节点（属性）：元素的属性。</li>
<li>文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。</li>
</ul>
<p>节点的类型不同，属性和方法也都不尽相同。所有的节点都是Object。</p>
<h4 id="什么是DOM-（操作DOM-和BOM是JavaScript在网页端运行的主要工作）"><a href="#什么是DOM-（操作DOM-和BOM是JavaScript在网页端运行的主要工作）" class="headerlink" title="什么是DOM （操作DOM 和BOM是JavaScript在网页端运行的主要工作）"></a>什么是DOM （操作DOM 和BOM是JavaScript在网页端运行的主要工作）</h4><p><strong>DOM</strong>：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。</p>
<p>DOM就是由节点组成的。</p>
<p><strong>解析过程</strong>： HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的<strong>属性</strong>。</p>
<p><strong>DOM树</strong>：（一切都是节点）</p>
<p>DOM的数据结构如下：</p>
<p><img src="http://img.smyhvae.com/20180126_2105.png" alt="img"></p>
<p>上图可知，<strong>在HTML当中，一切都是节点</strong>（非常重要）。节点的分类，在上一段中，已经讲了。</p>
<p>整个html文档就是一个文档节点。所有的节点都是Object。</p>
<h5 id="DOM可以做什么"><a href="#DOM可以做什么" class="headerlink" title="DOM可以做什么"></a>DOM可以做什么</h5><ul>
<li>找对象（元素节点）</li>
<li>设置元素的属性值</li>
<li>设置元素的样式</li>
<li>动态创建和删除元素</li>
<li>事件的触发响应：事件源、事件、事件的驱动程序</li>
</ul>
<h5 id="元素节点的获取"><a href="#元素节点的获取" class="headerlink" title="元素节点的获取"></a>元素节点的获取</h5><p>DOM节点的获取方式其实就是<strong>获取事件源的方式</strong>。</p>
<p>想要操作元素节点，必须首先要找到该节点。有三种方式可以获取DOM节点：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var div1 = document.getElementById("box1"); //方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的）<br><br>var arr1 = document.getElementsByTagName("div"); //方式二：通过 标签名 获取 元素节点数组，所以有s<br><br>var arr2 = document.getElementsByClassName("hehe"); //方式三：通过 类名 获取 元素节点数组，所以有s<br></code></pre></td></tr></tbody></table></figure>

<p>既然方式二、方式三获取的是标签数组，那么习惯性是<strong>先遍历之后再使用</strong>。</p>
<p>特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">document.getElementsByTagName("div1")[0];    //取数组中的第一个元素<br><br>document.getElementsByClassName("hehe")[0];  //取数组中的第一个元素<br></code></pre></td></tr></tbody></table></figure>



<h5 id="DOM访问关系的获取"><a href="#DOM访问关系的获取" class="headerlink" title="DOM访问关系的获取"></a>DOM访问关系的获取</h5><p>DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。如下：</p>
<p><img src="http://img.smyhvae.com/20180126_2140.png" alt="img"></p>
<p>节点的访问关系，是以<strong>属性</strong>的方式存在的。</p>
<p>JS中的<strong>父子兄</strong>访问关系：</p>
<p><img src="http://img.smyhvae.com/20180126_2145.png" alt="img"></p>
<h5 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h5><p>调用者就是节点。一个节点只有一个父节点，调用方式就是</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">节点.parentNode<br></code></pre></td></tr></tbody></table></figure>



<h5 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h5><p><strong>1、下一个节点 | 下一个元素节点</strong>：</p>
<blockquote>
<p>Sibling的中文是<strong>兄弟</strong>。</p>
</blockquote>
<p>（1）nextSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指下一个元素节点（标签）。</li>
</ul>
<p>（2）nextElementSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取下一个<strong>元素节点</strong>，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling<br></code></pre></td></tr></tbody></table></figure>



<p><strong>2、前一个节点 | 前一个元素节点</strong>：</p>
<blockquote>
<p>previous的中文是：前一个。</p>
</blockquote>
<p>（1）previousSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指前一个元素节点（标签）。</li>
</ul>
<p>（2）previousElementSibling：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取前一个<strong>元素节点</strong>，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling<br></code></pre></td></tr></tbody></table></figure>

<p><strong>3、补充</strong>：获得任意一个兄弟节点：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">节点自己.parentNode.children[index];  //随意得到兄弟节点<br></code></pre></td></tr></tbody></table></figure>



<h5 id="获取单个的子节点"><a href="#获取单个的子节点" class="headerlink" title="获取单个的子节点"></a><strong>获取单个的子节点</strong></h5><p><strong>1、第一个子节点 | 第一个子元素节点</strong>：</p>
<p>（1）firstChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指第一个子元素节点（标签）。</li>
</ul>
<p>（2）firstElementChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取第一个<strong>子元素节点</strong>，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">第一个子元素节点 = 节点.firstElementChild || 节点.firstChild<br></code></pre></td></tr></tbody></table></figure>



<p><strong>2、最后一个子节点 | 最后一个子元素节点</strong>：</p>
<p>（1）lastChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。</li>
<li>IE678版本：指最后一个子元素节点（标签）。</li>
</ul>
<p>（2）lastElementChild：</p>
<ul>
<li>火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。</li>
</ul>
<p><strong>总结</strong>：为了获取最后一个<strong>子元素节点</strong>，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild<br></code></pre></td></tr></tbody></table></figure>



<h5 id="获取所有的子节点"><a href="#获取所有的子节点" class="headerlink" title="获取所有的子节点"></a>获取所有的子节点</h5><p>（1）<strong>childNodes</strong>：标准属性。返回的是指定元素的<strong>子节点</strong>的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。</p>
<ul>
<li>火狐 谷歌等高本版会把换行也看做是子节点。</li>
</ul>
<p>用法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">子节点数组 = 父节点.childNodes;   //获取所有节点。<br></code></pre></td></tr></tbody></table></figure>

<p>（2）<strong>children</strong>：非标准属性。返回的是指定元素的<strong>子元素节点</strong>的集合。【重要】</p>
<ul>
<li>它只返回HTML节点，甚至不返回文本节点。</li>
<li>在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。</li>
</ul>
<p>虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。</p>
<p>用法：（<strong>用的最多</strong>）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">子节点数组 = 父节点.children;   //获取所有节点。用的最多。<br></code></pre></td></tr></tbody></table></figure>



<h5 id="DOM节点的操作（重要）"><a href="#DOM节点的操作（重要）" class="headerlink" title="DOM节点的操作（重要）"></a>DOM节点的操作（重要）</h5><p>上一段的内容：节点的<strong>访问关系</strong>都是<strong>属性</strong>。</p>
<p>本段的内容：节点的<strong>操作</strong>都是<strong>函数</strong>（方法）。</p>
<h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><p>格式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">新的标签(元素节点) = document.createElement("标签名");<br></code></pre></td></tr></tbody></table></figure>

<p>比如，如果我们想创建一个li标签，或者是创建一个不存在的adbc标签，可以这样做：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;script type="text/javascript"&gt;<br>    var a1 = document.createElement("li");   //创建一个li标签<br>    var a2 = document.createElement("adbc");   //创建一个不存在的标签<br><br>    console.log(a1);<br>    console.log(a2);<br><br>    console.log(typeof a1);<br>    console.log(typeof a2);<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180127_1135.png" alt="img"></p>
<h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><p>插入节点有两种方式，它们的含义是不同的。</p>
<p>方式1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">父节点.appendChild(新的子节点);<br></code></pre></td></tr></tbody></table></figure>

<p>解释：父节点的最后插入一个新的子节点。</p>
<p>方式2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">父节点.insertBefore(新的子节点,作为参考的子节点)<br></code></pre></td></tr></tbody></table></figure>

<p>解释：</p>
<ul>
<li>在参考节点前插入一个新的节点。</li>
<li>如果参考节点为null，那么他将在父节点里面的最后插入一个子节点。</li>
</ul>
<p><img src="http://img.smyhvae.com/20180127_1257.png" alt="img"></p>
<p>我们可以看到，li标签确实被插入到了box1标签的里面，和box2并列了。</p>
<p>方式2的举例：</p>
<p><img src="http://img.smyhvae.com/20180127_1302.png" alt="img"></p>
<p>我们可以看到，b1标签被插入到了box1标签的里面，和a1标签并列，在a1标签的前面。</p>
<p><strong>特别强调：</strong></p>
<p>关于方式1的appendChild方法，这里要强调一下。比如，现在有下面这样一个div结构：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;div class="box11"&gt;<br>    &lt;div class="box12"&gt;生命壹号&lt;/div&gt;<br>&lt;/div&gt;<br><br>&lt;div class="box21"&gt;<br>    &lt;div class="box22"&gt;永不止步&lt;/div&gt;<br><br>&lt;/div&gt;<br></code></pre></td></tr></tbody></table></figure>

<p>上方结构中，子盒子box12是在父亲box11里的，子盒子box22是在父亲box21里面的。现在，如果我调用方法<code>box11.appendChild(box22)</code>，<strong>最后产生的结果是：box22会跑到box11中</strong>（也就是说，box22不在box21里面了）。这是一个很神奇的事情：</p>
<p><img src="http://img.smyhvae.com/20180129_2125.png" alt="img"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">父节点.removeChild(子节点);<br></code></pre></td></tr></tbody></table></figure>

<p>解释：<strong>用父节点删除子节点</strong>。必须要指定是删除哪个子节点。</p>
<p>如果我想删除自己这个节点，可以这么做：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">node1.parentNode.removeChild(node1);<br></code></pre></td></tr></tbody></table></figure>



<h3 id="复制节点（克隆节点）"><a href="#复制节点（克隆节点）" class="headerlink" title="复制节点（克隆节点）"></a>复制节点（克隆节点）</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">要复制的节点.cloneNode();       //括号里不带参数和带参数false，效果是一样的。<br><br>要复制的节点.cloneNode(true);<br></code></pre></td></tr></tbody></table></figure>

<p>括号里带不带参数，效果是不同的。解释如下：</p>
<ul>
<li>不带参数/带参数false：只复制节点本身，不复制子节点。</li>
<li>带参数true：既复制节点本身，也复制其所有的子节点。</li>
</ul>
<h5 id="设置节点的属性"><a href="#设置节点的属性" class="headerlink" title="设置节点的属性"></a>设置节点的属性</h5><p>我们可以获取节点的属性值、设置节点的属性值、删除节点的属性。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src="images/1.jpg" class="image-box" title="美女图片" alt="地铁一瞥" id="a1"&gt;<br></code></pre></td></tr></tbody></table></figure>



<h5 id="1、获取节点的属性值"><a href="#1、获取节点的属性值" class="headerlink" title="1、获取节点的属性值"></a>1、获取节点的属性值</h5><p><strong>方式1</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">元素节点.属性名;<br>元素节点[属性名];<br></code></pre></td></tr></tbody></table></figure>

<p>举例：（获取节点的属性值）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;body&gt;<br>&lt;img src="images/1.jpg" class="image-box" title="美女图片" alt="地铁一瞥" id="a1"&gt;<br><br>&lt;script type="text/javascript"&gt;<br>    var myNode = document.getElementsByTagName("img")[0];<br><br>    console.log(myNode.src);<br>    console.log(myNode.className);    //注意，是className，不是class<br>    console.log(myNode.title);<br><br>    console.log("------------");<br><br>    console.log(myNode["src"]);<br>    console.log(myNode["className"]); //注意，是className，不是class<br>    console.log(myNode["title"]);<br>&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></tbody></table></figure>

<p>上方代码中的img标签，有各种属性，我们可以逐一获取，打印结果如下：</p>
<p><img src="http://img.smyhvae.com/20180127_1340.png" alt="img"></p>
<p><strong>方式2</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">元素节点.getAttribute("属性名称");<br></code></pre></td></tr></tbody></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log(myNode.getAttribute("src"));<br>console.log(myNode.getAttribute("class"));   //注意是class，不是className<br>console.log(myNode.getAttribute("title"));<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<p><img src="http://img.smyhvae.com/20180127_1345.png" alt="img"></p>
<p>方式1和方式2的区别在于：前者是直接操作标签，后者是把标签作为DOM节点。推荐方式2。</p>
<h5 id="2、设置节点的属性值"><a href="#2、设置节点的属性值" class="headerlink" title="2、设置节点的属性值"></a>2、设置节点的属性值</h5><p>方式1举例：（设置节点的属性值）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">myNode.src = "images/2.jpg"   //修改src的属性值<br>myNode.className = "image2-box";  //修改class的name<br></code></pre></td></tr></tbody></table></figure>

<p>方式2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">元素节点.setAttribute(属性名, 新的属性值);<br></code></pre></td></tr></tbody></table></figure>

<p>方式2举例：（设置节点的属性值）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">myNode.setAttribute("src","images/3.jpg");<br>myNode.setAttribute("class","image3-box");<br>myNode.setAttribute("id","你好");<br></code></pre></td></tr></tbody></table></figure>



<h5 id="3、删除节点的属性"><a href="#3、删除节点的属性" class="headerlink" title="3、删除节点的属性"></a>3、删除节点的属性</h5><p>格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">元素节点.removeAttribute(属性名);<br></code></pre></td></tr></tbody></table></figure>

<p>举例：（删除节点的属性）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">myNode.removeAttribute("class");<br>myNode.removeAttribute("id");<br></code></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong></p>
<p>获取节点的属性值和设置节点的属性值，都有两种方式，但这两种方式是有区别的。</p>
<ul>
<li>方式一的<code>元素节点.属性</code>和<code>元素节点[属性]</code>:绑定的属性值不会出现在标签上。</li>
<li>方式二的<code>get/set/removeAttribut</code>: 绑定的属性值会出现在标签上。</li>
</ul>
<p>这其实很好理解，方式一操作的是属性而已，方式二操作的是标签本身。</p>
<p>另外，需要注意的是：<strong>这两种方式不能交换使用</strong>，get值和set值必须使用用一种方法。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;body&gt;<br>&lt;div id="box" title="主体" class="asdfasdfadsfd"&gt;我爱你中国&lt;/div&gt;<br>&lt;script&gt;<br><br>    var div = document.getElementById("box");<br><br>    //采用方式一进行set<br>    div.aaaa = "1111";<br>    console.log(div.aaaa);    //打印结果：1111。可以打印出来，但是不会出现在标签上<br><br>    //采用方式二进行set<br>    div.setAttribute("bbbb","2222");    //bbbb作为新增的属性，会出现在标签上<br><br>    console.log(div.getAttribute("aaaa"));   //打印结果：null。因为方式一的set，无法采用方式二进行get。<br>    console.log(div.bbbb);                   //打印结果：undefined。因为方式二的set，无法采用方式一进行get。<br><br>&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></tbody></table></figure>



<h5 id="DOM对象的属性"><a href="#DOM对象的属性" class="headerlink" title="DOM对象的属性"></a>DOM对象的属性</h5><p>DOM对象的属性和HTML的标签属性几乎是一致的。例如：src、title、className、href等。</p>
<h5 id="innerHTML和innerText的区别"><a href="#innerHTML和innerText的区别" class="headerlink" title="innerHTML和innerText的区别"></a>innerHTML和innerText的区别</h5><ul>
<li>value：标签的value属性。</li>
<li><strong>innerHTML</strong>：双闭合标签里面的内容（识别标签）。</li>
<li><strong>innerText</strong>：双闭合标签里面的内容（不识别标签）。（老版本的火狐用textContent）</li>
</ul>
<p><strong>获取内容举例：</strong></p>
<p>如果我们想获取innerHTML和innerText里的内容，看看会如何：（innerHTML会获取到标签本身，而innerText则不会）</p>
<p><img src="http://img.smyhvae.com/20180127_1652.png" alt="img"></p>
<p><strong>修改内容举例：</strong>（innerHTML会修改标签本身，而innerText则不会）</p>
<p><img src="http://img.smyhvae.com/20180127_1657.png" alt="img"></p>
<h5 id="nodeType属性"><a href="#nodeType属性" class="headerlink" title="nodeType属性"></a>nodeType属性</h5><p>这里讲一下nodeType属性。</p>
<ul>
<li><strong>nodeType == 1  表示的是元素节点</strong>（标签） 。记住：元素就是标签。</li>
<li>nodeType == 2  表示是属性节点。</li>
<li>nodeType == 3  是文本节点。</li>
</ul>
<h3 id="nodeType、nodeName、nodeValue"><a href="#nodeType、nodeName、nodeValue" class="headerlink" title="nodeType、nodeName、nodeValue"></a>nodeType、nodeName、nodeValue</h3><p>我们那下面这个标签来举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;div id="box" value="111"&gt;<br>    生命壹号<br>&lt;/div&gt;<br></code></pre></td></tr></tbody></table></figure>

<p>上面这个标签就包含了三种节点：</p>
<ul>
<li>元素节点（标签）</li>
<li>属性节点</li>
<li>文本节点</li>
</ul>
<p>获取这三个节点的方式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var element = document.getElementById("box1");  //获取元素节点（标签）<br>var attribute = element.getAttributeNode("id"); //获取box1的属性节点<br>var txt = element.firstChild;                   //获取box1的文本节点<br><br>var value = element.getAttribute("id");         //获取id的属性值<br><br>console.log(element);<br>console.log("--------------");<br>console.log(attribute);<br>console.log("--------------");<br>console.log(txt);<br>console.log("--------------");<br>console.log(value);<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果如下：</p>
<p><img src="http://img.smyhvae.com/20180128_1935.png" alt="img"></p>
<p>既然这三个都是节点，如果我想获取它们的nodeType、nodeName、nodeValue，代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var element = document.getElementById("box1");  //获取元素节点（标签）<br>var attribute = element.getAttributeNode("id"); //获取box1的属性节点<br>var txt = element.firstChild;                   //获取box1的文本节点<br><br>//获取nodeType<br>console.log(element.nodeType);       //1<br>console.log(attribute.nodeType);     //2<br>console.log(txt.nodeType);           //3<br><br>console.log("--------------");<br><br>//获取nodeName<br>console.log(element.nodeName);       //DIV<br>console.log(attribute.nodeName);     //id<br>console.log(txt.nodeName);           //#text<br><br>console.log("--------------");<br><br>//获取nodeValue<br>console.log(element.nodeValue);     //null<br>console.log(attribute.nodeValue);   //box1<br>console.log(txt.nodeValue);         //生命壹号<br></code></pre></td></tr></tbody></table></figure>

<p>打印结果如下：</p>
<p><img src="http://img.smyhvae.com/20180128_1939.png" alt="img"></p>
<h4 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载"></a>文档的加载</h4><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致无法获取到DOM对象。</p>
<p><strong>onload 事件</strong>：</p>
<p>onload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。</p>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;meta charset="UTF-8" /&gt;<br>    &lt;title&gt;&lt;/title&gt;<br>    &lt;script type="text/javascript"&gt;<br>      // 【方式一：先加载，后执行】这段 js 代码是写在 &lt;head&gt; 标签里的，所以建议放在 window.onload 里面。<br>      window.onload = function() {<br>        // 获取id为btn的按钮<br>        var btn = document.getElementById("btn");<br>        // 为按钮绑定点击事件<br>        btn.onclick = function() {<br>          alert("hello");<br>        };<br>      };<br>    &lt;/script&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;button id="btn"&gt;点我一下&lt;/button&gt;<br><br>    &lt;script type="text/javascript"&gt;<br>      // 【方式二：后加载，后执行】这段 js 代码是写在 &lt;body&gt; 标签里的，代码的位置是处在页面的下方。这么做，也可以确保：在页面加载完毕后，再执行 js 代码。<br><br>      // 获取id为btn的按钮<br>      var btn = document.getElementById("btn");<br>      // 为按钮绑定点击事件<br>      btn.onclick = function() {<br>        alert("hello");<br>      };<br>    &lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br><br><br></code></pre></td></tr></tbody></table></figure>



<h4 id="事件简介"><a href="#事件简介" class="headerlink" title="事件简介"></a>事件简介</h4><p>事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间。对于 Web 应用来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等等。</p>
<p>JavaScript 是以<strong>事件驱动为核心</strong>的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。</p>
<h5 id="事件的三要素"><a href="#事件的三要素" class="headerlink" title="事件的三要素"></a>事件的三要素</h5><p><strong>事件的三要素：事件源、事件、事件驱动程序。</strong></p>
<p>比如，我用手去按开关，灯亮了。这件事情里，事件源是：手。事件是：按开关。事件驱动程序是：灯开了或者关了。</p>
<p>再比如，网页上弹出一个广告，我点击右上角的<code>X</code>，广告就关闭了。这件事情里，事件源是：<code>X</code>。事件是：onclick。事件驱动程序是：广告关闭了。</p>
<p>于是我们可以总结出：谁引发的后续事件，谁就是事件源。</p>
<p><strong>总结如下：</strong></p>
<ul>
<li>事件源：引发后续事件的html标签。</li>
<li>事件：js已经定义好了（见下图）。</li>
<li>事件驱动程序：对样式和html的操作。也就是DOM。</li>
</ul>
<p>也就是说，我们可以在时间对应的属性中写一些js代码，当事件被触发时，这些代码将会执行。</p>
<p><strong>代码书写步骤如下：</strong>（重要）</p>
<ul>
<li>（1）获取事件源：document.getElementById(“box”);   // 类似于Android里面的findViewById</li>
<li>（2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 };</li>
<li>（3）书写事件驱动程序：关于DOM的操作。</li>
</ul>
<p><strong>Javascript事件分 冒泡和捕获</strong> </p>
<h4 id="BOM的介绍"><a href="#BOM的介绍" class="headerlink" title="BOM的介绍"></a>BOM的介绍</h4><h3 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h3><p>BOM：Browser Object Model，浏览器对象模型。</p>
<p><strong>BOM的结构图：</strong></p>
<p><img src="http://img.smyhvae.com/20180201_2052.png" alt="img"></p>
<p>从上图也可以看出：</p>
<ul>
<li><strong>window对象是BOM的顶层(核心)对象</strong>，所有对象都是通过它延伸出来的，也可以称为window的子对象。</li>
<li>DOM也是BOM的一部分。</li>
</ul>
<p><strong>window对象：</strong></p>
<ul>
<li><strong>window对象是JavaScript中的顶级对象</strong>。</li>
<li>全局变量、自定义函数也是window对象的属性和方法。</li>
<li>window对象下的属性和方法调用时，可以省略window。</li>
</ul>
<p>下面讲一下 <strong>BOM 的常见内置方法和内置对象</strong>。</p>
<h5 id="弹出系统对话框"><a href="#弹出系统对话框" class="headerlink" title="弹出系统对话框"></a>弹出系统对话框</h5><p>比如说，<code>alert(1)</code>是<code>window.alert(1)</code>的简写，因为它是window的子方法。</p>
<p>系统对话框有三种：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">alert();    //不同浏览器中的外观是不一样的<br>confirm();  //兼容不好<br>prompt();   //不推荐使用<br><br></code></pre></td></tr></tbody></table></figure>



<h5 id="打开窗口、关闭窗口"><a href="#打开窗口、关闭窗口" class="headerlink" title="打开窗口、关闭窗口"></a>打开窗口、关闭窗口</h5><p>1、打开窗口：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">window.open(url,target,param)<br></code></pre></td></tr></tbody></table></figure>

<p><strong>参数解释：</strong></p>
<ul>
<li>url：要打开的地址。</li>
<li>target：新窗口的位置。可以是：<code>_blank</code> 、<code>_self</code>、 <code>_parent</code> 父框架。</li>
<li>param：新窗口的一些设置。</li>
<li>返回值：新窗口的句柄。</li>
</ul>
<p><strong>param</strong>这个参数，可以填各种各样的参数（），比如：</p>
<ul>
<li>name：新窗口的名称，可以为空</li>
<li>features：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。</li>
<li>fullscreen= { yes/no/1/0 } 是否全屏，默认no</li>
<li>channelmode= { yes/no/1/0 } 是否显示频道栏，默认no</li>
<li>toolbar= { yes/no/1/0 } 是否显示工具条，默认no</li>
<li>location= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持）</li>
<li>directories = { yes/no/1/0 } 是否显示转向按钮，默认no</li>
<li>status= { yes/no/1/0 } 是否显示窗口状态条，默认no</li>
<li>menubar= { yes/no/1/0 } 是否显示菜单，默认no</li>
<li>scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes</li>
<li>resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no</li>
<li>width=number 窗口宽度（像素单位）</li>
<li>height=number 窗口高度（像素单位）</li>
<li>top=number 窗口离屏幕顶部距离（像素单位）</li>
<li>left=number 窗口离屏幕左边距离（像素单位）</li>
</ul>
<p>各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。</p>
<p>2、关闭窗口：window.close()</p>
<p>（1）和（2）的代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head lang="en"&gt;<br>    &lt;meta charset="UTF-8"&gt;<br>    &lt;title&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;a href="javascript:;"&gt;点击我打开一个新的页面&lt;/a&gt;<br>&lt;a href="javascript:;"&gt;点击我关闭本页面&lt;/a&gt;<br>&lt;script&gt;<br>    //新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数);<br>    var a1 = document.getElementsByTagName("a")[0];<br>    var a2 = document.getElementsByTagName("a")[1];<br>    a1.onclick = function () {<br>//举例1： window.open("http://www.jx.com","_blank");<br>        var json = {<br>            "name": "helloworld",<br>            "fullscreen": "no",<br>            "location": "no",<br>            "width": "600px",<br>            "height": "400px",<br>            "top": "100px",<br>            "left": "100px"<br>        };<br>        window.open("http://www.baidu.com", "_blank", json); //举例2<br>    }<br><br>    //关闭本页面<br>    a2.onclick = function () {<br>        window.close();<br>    }<br>&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></tbody></table></figure>



<p>3、新窗口相关：</p>
<ul>
<li>新窗口.moveTo(5,5)</li>
<li>新窗口.moveBy()</li>
<li>新窗口.resizeTo()</li>
<li>window.resizeBy()</li>
</ul>
<p>代码举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">var newWin = window.open("demo.html", "_blank", json);<br>newWin.moveTo(500, 500);<br></code></pre></td></tr></tbody></table></figure>



<h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><p><code>window.location</code>可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。</p>
<h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><ul>
<li><strong>href</strong>：跳转</li>
<li>hash   返回url中#后面的内容，包含#</li>
<li>host    主机名，包括端口</li>
<li>hostname   主机名</li>
<li>pathname     url中的路径部分</li>
<li>protocol    协议 一般是http、https</li>
<li>search         查询字符串</li>
</ul>
<p><strong>location.href属性举例</strong>：</p>
<p><strong>举例1：</strong>点击盒子时，进行跳转。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;body&gt;<br>&lt;div&gt;smyhvae&lt;/div&gt;<br>&lt;script&gt;<br><br>    var div = document.getElementsByTagName("div")[0];<br><br>    div.onclick = function () {<br>        location.href = "http://www.baidu.com";   //点击div时，跳转到指定链接<br> //     window.open("http://www.baidu.com","_blank");  //方式二<br>    }<br><br>&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></tbody></table></figure>

<p><strong>举例2：5秒后自动跳转到百度</strong>。</p>
<p>有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br><br>    setTimeout(function () {<br>        location.href = "http://www.baidu.com";<br>    }, 5000);<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure>



<h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><ul>
<li>location.assign()：改变浏览器地址栏的地址，并记录到历史中</li>
</ul>
<p>设置location.href  就会调用assign()。一般使用location.href 进行页面之间的跳转。</p>
<ul>
<li>location.replace()：替换浏览器地址栏的地址，不会记录到历史中</li>
<li>location.reload()：重新加载</li>
</ul>
<h5 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h5><p>window.navigator 的一些属性可以获取客户端的一些信息。</p>
<ul>
<li>userAgent：系统，浏览器)</li>
<li>platform：浏览器支持的系统，win/mac/linux</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">console.log(navigator.userAgent);<br>console.log(navigator.platform);<br></code></pre></td></tr></tbody></table></figure>

<p>效果如下：</p>
<p><img src="http://img.smyhvae.com/20180201_2140.png" alt="img"></p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>1、历史记录管理</p>
<p>2、后退：</p>
<ul>
<li>history.back()</li>
<li>history.go(-1)：0是刷新</li>
</ul>
<p>3、前进：</p>
<ul>
<li>history.forward()</li>
<li>history.go(1)</li>
</ul>
<p>用的不多。因为浏览器中已经自带了这些功能的按钮：</p>
<p><img src="http://img.smyhvae.com/20180201_2146.png" alt="img"></p>
<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>设置计时器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">let time = setInterval(function () {<br><br>    console.log(this);<br><br>  }, 300)<br></code></pre></td></tr></tbody></table></figure>

<p> 暂停计时器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">clearInterval(time);<br></code></pre></td></tr></tbody></table></figure>



<p>setTimeout 延时器</p>
<p>clearTimeout 关闭延时器</p>
<h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><p>将WEB页面中的数据存放到本地</p>
<h5 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h5><p>可以永久存放到本地，但是只要清除掉浏览器的缓存，即可删除数据。</p>
<h3 id="存放数据"><a href="#存放数据" class="headerlink" title="存放数据"></a>存放数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">localStorage.newsTitle = "跻身前40！中国营商环境全球排名再度提升"<br>localStorage['author'] = "今日头条"<br>localStorage.setItem("content","习近平指出，中国秉持创新、协调、绿色、开放、共享的发展理念，推动<br></code></pre></td></tr></tbody></table></figure>

<h3 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">document.write("&lt;h1&gt;"+localStorage.newsTitle+"&lt;/h1&gt;")<br>document.write("&lt;h2&gt;"+localStorage['author']+"&lt;/h2&gt;")<br>document.write("&lt;p&gt;"+localStorage.getItem("content")+"&lt;/p&gt;")<br></code></pre></td></tr></tbody></table></figure>

<h3 id="清除1条数据"><a href="#清除1条数据" class="headerlink" title="清除1条数据"></a>清除1条数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">localStorage.removeItem("author")<br></code></pre></td></tr></tbody></table></figure>

<h3 id="清除所有数据"><a href="#清除所有数据" class="headerlink" title="清除所有数据"></a>清除所有数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">localStorage.clear()<br></code></pre></td></tr></tbody></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h5 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h5><p>本地存放的数据当次有效。主要关闭页面就会将数据清除掉。</p>
<h3 id="存放数据-1"><a href="#存放数据-1" class="headerlink" title="存放数据"></a>存放数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">sessionStorage.newsTitle = "跻身前40！中国营商环境全球排名再度提升"<br>sessionStorage['author'] = "今日头条"<br>sessionStorage.setItem("content","习近平指出，中国秉持创新、协调、绿色、开放、共享的发展理念，推动<br></code></pre></td></tr></tbody></table></figure>

<h3 id="取数据-1"><a href="#取数据-1" class="headerlink" title="取数据"></a>取数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">document.write("&lt;h1&gt;"+sessionStorage.newsTitle+"&lt;/h1&gt;")<br>document.write("&lt;h2&gt;"+sessionStorage['author']+"&lt;/h2&gt;")<br>document.write("&lt;p&gt;"+sessionStorage.getItem("content")+"&lt;/p&gt;")<br></code></pre></td></tr></tbody></table></figure>

<h3 id="清除1条数据-1"><a href="#清除1条数据-1" class="headerlink" title="清除1条数据"></a>清除1条数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">sessionStorage.removeItem("author")<br></code></pre></td></tr></tbody></table></figure>

<h3 id="清除所有数据-1"><a href="#清除所有数据-1" class="headerlink" title="清除所有数据"></a>清除所有数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><code class="hljs plaintext">sessionStorage.clear()<br></code></pre></td></tr></tbody></table></figure>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">形骸</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://1360998057.github.io/2021/04/25/javascript-ji-chu/">https://1360998057.github.io/2021/04/25/javascript-ji-chu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">形骸</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Javascript/">
                                    <span class="chip bg-color">Javascript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/05/02/qian-duan-dan-wei/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="前端常用单位">
                        
                        <span class="card-title">前端常用单位</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-05-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CSS/">
                        <span class="chip bg-color">CSS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/06/23/vue-devtools/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="Vue-devtools">
                        
                        <span class="card-title">Vue-devtools</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-06-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Javascript/" class="post-category">
                                    Javascript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Vue/">
                        <span class="chip bg-color">Vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        <
        %
        if (theme.toc.enable && theme.toc.showToggleBtn) {
            % >
            /* 修复文章卡片 div 的宽度. */
            let fixPostCardWidth = function (srcId, targetId) {
                let srcDiv = $('#' + srcId);
                if (srcDiv.length === 0) {
                    return;
                }

                let w = srcDiv.width();
                if (w >= 450) {
                    w = w + 21;
                } else if (w >= 350 && w < 450) {
                    w = w + 18;
                } else if (w >= 300 && w < 350) {
                    w = w + 16;
                } else {
                    w = w + 14;
                }
                $('#' + targetId).width(w);
            };

            // 切换TOC目录展开收缩的相关操作.
            const expandedClass = 'expanded';
            let $tocAside = $('#toc-aside');
            let $mainContent = $('#main-content');
            $('#floating-toc-btn .btn-floating').click(function () {
                if ($tocAside.hasClass(expandedClass)) {
                    $tocAside.removeClass(expandedClass).hide();
                    $mainContent.removeClass('l9');
                } else {
                    $tocAside.addClass(expandedClass).show();
                    $mainContent.addClass('l9');
                }
                fixPostCardWidth('artDetail', 'prenext-posts');
            }); <
            %
        } % >
    });
</script>
    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2829896389"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.4'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">形骸</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/1360998057" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1360998057@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1360998057" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1360998057" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js"
        async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>